{
  "version": 3,
  "sources": ["../../hookable/dist/index.mjs", "../../unctx/dist/index.mjs", "../../nuxt/dist/app/nuxt.mjs", "../../ufo/dist/index.mjs", "../../destr/dist/index.mjs", "../../cookie-es/dist/index.mjs", "../../h3/dist/index.mjs", "../../nuxt/dist/app/composables/error.mjs", "../../nuxt/dist/app/composables/asyncData.mjs", "../../nuxt/dist/app/composables/state.mjs", "../../nuxt/dist/app/composables/ssr.mjs", "../../nuxt/dist/app/composables/router.mjs", "../../@unhead/vue/dist/index.mjs", "../../@vueuse/head/dist/index.mjs", "../../nuxt/dist/head/runtime/composables.mjs", "../../nuxt/dist/app/composables/component.mjs", "../../nuxt/dist/app/composables/hydrate.mjs", "../../ohash/dist/index.mjs", "../../nuxt/dist/app/composables/fetch.mjs", "../../nuxt/dist/app/composables/cookie.mjs", "../../nuxt/dist/app/compat/idle-callback.mjs", "../../nuxt/dist/app/composables/ready.mjs", "../../nuxt/dist/app/composables/preload.mjs", "../../nuxt/dist/app/composables/payload.mjs", "../../nuxt/dist/app/components/nuxt-link.mjs", "../../defu/dist/defu.mjs", "../../../.nuxt/app.config.mjs", "../../nuxt/dist/app/config.mjs", "../../nuxt/dist/app/index.mjs"],
  "sourcesContent": ["function flatHooks(configHooks, hooks = {}, parentName) {\n  for (const key in configHooks) {\n    const subHook = configHooks[key];\n    const name = parentName ? `${parentName}:${key}` : key;\n    if (typeof subHook === \"object\" && subHook !== null) {\n      flatHooks(subHook, hooks, name);\n    } else if (typeof subHook === \"function\") {\n      hooks[name] = subHook;\n    }\n  }\n  return hooks;\n}\nfunction mergeHooks(...hooks) {\n  const finalHooks = {};\n  for (const hook of hooks) {\n    const flatenHook = flatHooks(hook);\n    for (const key in flatenHook) {\n      if (finalHooks[key]) {\n        finalHooks[key].push(flatenHook[key]);\n      } else {\n        finalHooks[key] = [flatenHook[key]];\n      }\n    }\n  }\n  for (const key in finalHooks) {\n    if (finalHooks[key].length > 1) {\n      const array = finalHooks[key];\n      finalHooks[key] = (...arguments_) => serial(array, (function_) => function_(...arguments_));\n    } else {\n      finalHooks[key] = finalHooks[key][0];\n    }\n  }\n  return finalHooks;\n}\nfunction serial(tasks, function_) {\n  return tasks.reduce((promise, task) => promise.then(() => function_(task)), Promise.resolve());\n}\nfunction serialCaller(hooks, arguments_) {\n  return hooks.reduce((promise, hookFunction) => promise.then(() => hookFunction.apply(void 0, arguments_)), Promise.resolve());\n}\nfunction parallelCaller(hooks, arguments_) {\n  return Promise.all(hooks.map((hook) => hook.apply(void 0, arguments_)));\n}\nfunction callEachWith(callbacks, argument0) {\n  for (const callback of callbacks) {\n    callback(argument0);\n  }\n}\n\nclass Hookable {\n  constructor() {\n    this._hooks = {};\n    this._before = void 0;\n    this._after = void 0;\n    this._deprecatedMessages = void 0;\n    this._deprecatedHooks = {};\n    this.hook = this.hook.bind(this);\n    this.callHook = this.callHook.bind(this);\n    this.callHookWith = this.callHookWith.bind(this);\n  }\n  hook(name, function_, options = {}) {\n    if (!name || typeof function_ !== \"function\") {\n      return () => {\n      };\n    }\n    const originalName = name;\n    let dep;\n    while (this._deprecatedHooks[name]) {\n      dep = this._deprecatedHooks[name];\n      name = dep.to;\n    }\n    if (dep && !options.allowDeprecated) {\n      let message = dep.message;\n      if (!message) {\n        message = `${originalName} hook has been deprecated` + (dep.to ? `, please use ${dep.to}` : \"\");\n      }\n      if (!this._deprecatedMessages) {\n        this._deprecatedMessages = /* @__PURE__ */ new Set();\n      }\n      if (!this._deprecatedMessages.has(message)) {\n        console.warn(message);\n        this._deprecatedMessages.add(message);\n      }\n    }\n    this._hooks[name] = this._hooks[name] || [];\n    this._hooks[name].push(function_);\n    return () => {\n      if (function_) {\n        this.removeHook(name, function_);\n        function_ = void 0;\n      }\n    };\n  }\n  hookOnce(name, function_) {\n    let _unreg;\n    let _function = (...arguments_) => {\n      if (typeof _unreg === \"function\") {\n        _unreg();\n      }\n      _unreg = void 0;\n      _function = void 0;\n      return function_(...arguments_);\n    };\n    _unreg = this.hook(name, _function);\n    return _unreg;\n  }\n  removeHook(name, function_) {\n    if (this._hooks[name]) {\n      const index = this._hooks[name].indexOf(function_);\n      if (index !== -1) {\n        this._hooks[name].splice(index, 1);\n      }\n      if (this._hooks[name].length === 0) {\n        delete this._hooks[name];\n      }\n    }\n  }\n  deprecateHook(name, deprecated) {\n    this._deprecatedHooks[name] = typeof deprecated === \"string\" ? { to: deprecated } : deprecated;\n    const _hooks = this._hooks[name] || [];\n    this._hooks[name] = void 0;\n    for (const hook of _hooks) {\n      this.hook(name, hook);\n    }\n  }\n  deprecateHooks(deprecatedHooks) {\n    Object.assign(this._deprecatedHooks, deprecatedHooks);\n    for (const name in deprecatedHooks) {\n      this.deprecateHook(name, deprecatedHooks[name]);\n    }\n  }\n  addHooks(configHooks) {\n    const hooks = flatHooks(configHooks);\n    const removeFns = Object.keys(hooks).map((key) => this.hook(key, hooks[key]));\n    return () => {\n      for (const unreg of removeFns.splice(0, removeFns.length)) {\n        unreg();\n      }\n    };\n  }\n  removeHooks(configHooks) {\n    const hooks = flatHooks(configHooks);\n    for (const key in hooks) {\n      this.removeHook(key, hooks[key]);\n    }\n  }\n  callHook(name, ...arguments_) {\n    return this.callHookWith(serialCaller, name, ...arguments_);\n  }\n  callHookParallel(name, ...arguments_) {\n    return this.callHookWith(parallelCaller, name, ...arguments_);\n  }\n  callHookWith(caller, name, ...arguments_) {\n    const event = this._before || this._after ? { name, args: arguments_, context: {} } : void 0;\n    if (this._before) {\n      callEachWith(this._before, event);\n    }\n    const result = caller(this._hooks[name] || [], arguments_);\n    if (result instanceof Promise) {\n      return result.finally(() => {\n        if (this._after && event) {\n          callEachWith(this._after, event);\n        }\n      });\n    }\n    if (this._after && event) {\n      callEachWith(this._after, event);\n    }\n    return result;\n  }\n  beforeEach(function_) {\n    this._before = this._before || [];\n    this._before.push(function_);\n    return () => {\n      const index = this._before.indexOf(function_);\n      if (index !== -1) {\n        this._before.splice(index, 1);\n      }\n    };\n  }\n  afterEach(function_) {\n    this._after = this._after || [];\n    this._after.push(function_);\n    return () => {\n      const index = this._after.indexOf(function_);\n      if (index !== -1) {\n        this._after.splice(index, 1);\n      }\n    };\n  }\n}\nfunction createHooks() {\n  return new Hookable();\n}\n\nconst isBrowser = typeof window !== \"undefined\";\nfunction createDebugger(hooks, _options = {}) {\n  const options = {\n    inspect: isBrowser,\n    group: isBrowser,\n    filter: () => true,\n    ..._options\n  };\n  const _filter = options.filter;\n  const filter = typeof _filter === \"string\" ? (name) => name.startsWith(_filter) : _filter;\n  const _tag = options.tag ? `[${options.tag}] ` : \"\";\n  const logPrefix = (event) => _tag + event.name + \"\".padEnd(event._id, \"\\0\");\n  const _idCtr = {};\n  const unsubscribeBefore = hooks.beforeEach((event) => {\n    if (!filter(event.name)) {\n      return;\n    }\n    _idCtr[event.name] = _idCtr[event.name] || 0;\n    event._id = _idCtr[event.name]++;\n    console.time(logPrefix(event));\n  });\n  const unsubscribeAfter = hooks.afterEach((event) => {\n    if (!filter(event.name)) {\n      return;\n    }\n    if (options.group) {\n      console.groupCollapsed(event.name);\n    }\n    if (options.inspect) {\n      console.timeLog(logPrefix(event), event.args);\n    } else {\n      console.timeEnd(logPrefix(event));\n    }\n    if (options.group) {\n      console.groupEnd();\n    }\n    _idCtr[event.name]--;\n  });\n  return {\n    close: () => {\n      unsubscribeBefore();\n      unsubscribeAfter();\n    }\n  };\n}\n\nexport { Hookable, createDebugger, createHooks, flatHooks, mergeHooks, parallelCaller, serial, serialCaller };\n", "function createContext() {\n  let currentInstance;\n  let isSingleton = false;\n  const checkConflict = (instance) => {\n    if (currentInstance && currentInstance !== instance) {\n      throw new Error(\"Context conflict\");\n    }\n  };\n  return {\n    use: () => {\n      if (currentInstance === void 0) {\n        throw new Error(\"Context is not available\");\n      }\n      return currentInstance;\n    },\n    tryUse: () => {\n      return currentInstance;\n    },\n    set: (instance, replace) => {\n      if (!replace) {\n        checkConflict(instance);\n      }\n      currentInstance = instance;\n      isSingleton = true;\n    },\n    unset: () => {\n      currentInstance = void 0;\n      isSingleton = false;\n    },\n    call: (instance, callback) => {\n      checkConflict(instance);\n      currentInstance = instance;\n      try {\n        return callback();\n      } finally {\n        if (!isSingleton) {\n          currentInstance = void 0;\n        }\n      }\n    },\n    async callAsync(instance, callback) {\n      currentInstance = instance;\n      const onRestore = () => {\n        currentInstance = instance;\n      };\n      const onLeave = () => currentInstance === instance ? onRestore : void 0;\n      asyncHandlers.add(onLeave);\n      try {\n        const r = callback();\n        if (!isSingleton) {\n          currentInstance = void 0;\n        }\n        return await r;\n      } finally {\n        asyncHandlers.delete(onLeave);\n      }\n    }\n  };\n}\nfunction createNamespace() {\n  const contexts = {};\n  return {\n    get(key) {\n      if (!contexts[key]) {\n        contexts[key] = createContext();\n      }\n      contexts[key];\n      return contexts[key];\n    }\n  };\n}\nconst _globalThis = typeof globalThis !== \"undefined\" ? globalThis : typeof self !== \"undefined\" ? self : typeof global !== \"undefined\" ? global : typeof window !== \"undefined\" ? window : {};\nconst globalKey = \"__unctx__\";\nconst defaultNamespace = _globalThis[globalKey] || (_globalThis[globalKey] = createNamespace());\nconst getContext = (key) => defaultNamespace.get(key);\nconst useContext = (key) => getContext(key).use;\nconst asyncHandlersKey = \"__unctx_async_handlers__\";\nconst asyncHandlers = _globalThis[asyncHandlersKey] || (_globalThis[asyncHandlersKey] = /* @__PURE__ */ new Set());\nfunction executeAsync(function_) {\n  const restores = [];\n  for (const leaveHandler of asyncHandlers) {\n    const restore2 = leaveHandler();\n    if (restore2) {\n      restores.push(restore2);\n    }\n  }\n  const restore = () => {\n    for (const restore2 of restores) {\n      restore2();\n    }\n  };\n  let awaitable = function_();\n  if (awaitable && typeof awaitable === \"object\" && \"catch\" in awaitable) {\n    awaitable = awaitable.catch((error) => {\n      restore();\n      throw error;\n    });\n  }\n  return [awaitable, restore];\n}\nfunction withAsyncContext(function_, transformed) {\n  if (!transformed) {\n    console.warn(\"[unctx] `withAsyncContext` needs transformation for async context support in\", function_, \"\\n\", function_.toString());\n  }\n  return function_;\n}\n\nexport { createContext, createNamespace, defaultNamespace, executeAsync, getContext, useContext, withAsyncContext };\n", "import { getCurrentInstance, reactive } from \"vue\";\nimport { createHooks } from \"hookable\";\nimport { getContext } from \"unctx\";\nconst nuxtAppCtx = getContext(\"nuxt-app\");\nexport const NuxtPluginIndicator = \"__nuxt_plugin\";\nexport function createNuxtApp(options) {\n  let hydratingCount = 0;\n  const nuxtApp = {\n    provide: void 0,\n    globalName: \"nuxt\",\n    payload: reactive({\n      data: {},\n      state: {},\n      _errors: {},\n      ...process.client ? window.__NUXT__ : { serverRendered: true }\n    }),\n    static: {\n      data: {}\n    },\n    isHydrating: process.client,\n    deferHydration() {\n      if (!nuxtApp.isHydrating) {\n        return () => {\n        };\n      }\n      hydratingCount++;\n      let called = false;\n      return () => {\n        if (called) {\n          return;\n        }\n        called = true;\n        hydratingCount--;\n        if (hydratingCount === 0) {\n          nuxtApp.isHydrating = false;\n          return nuxtApp.callHook(\"app:suspense:resolve\");\n        }\n      };\n    },\n    _asyncDataPromises: {},\n    _asyncData: {},\n    ...options\n  };\n  nuxtApp.hooks = createHooks();\n  nuxtApp.hook = nuxtApp.hooks.hook;\n  nuxtApp.callHook = nuxtApp.hooks.callHook;\n  nuxtApp.provide = (name, value) => {\n    const $name = \"$\" + name;\n    defineGetter(nuxtApp, $name, value);\n    defineGetter(nuxtApp.vueApp.config.globalProperties, $name, value);\n  };\n  defineGetter(nuxtApp.vueApp, \"$nuxt\", nuxtApp);\n  defineGetter(nuxtApp.vueApp.config.globalProperties, \"$nuxt\", nuxtApp);\n  if (process.server) {\n    if (nuxtApp.ssrContext) {\n      nuxtApp.ssrContext.nuxt = nuxtApp;\n    }\n    nuxtApp.ssrContext = nuxtApp.ssrContext || {};\n    if (nuxtApp.ssrContext.payload) {\n      Object.assign(nuxtApp.payload, nuxtApp.ssrContext.payload);\n    }\n    nuxtApp.ssrContext.payload = nuxtApp.payload;\n    nuxtApp.payload.config = {\n      public: options.ssrContext.runtimeConfig.public,\n      app: options.ssrContext.runtimeConfig.app\n    };\n  }\n  const runtimeConfig = process.server ? options.ssrContext.runtimeConfig : reactive(nuxtApp.payload.config);\n  const compatibilityConfig = new Proxy(runtimeConfig, {\n    get(target, prop) {\n      if (prop === \"public\") {\n        return target.public;\n      }\n      return target[prop] ?? target.public[prop];\n    },\n    set(target, prop, value) {\n      if (process.server || prop === \"public\" || prop === \"app\") {\n        return false;\n      }\n      target[prop] = value;\n      target.public[prop] = value;\n      return true;\n    }\n  });\n  nuxtApp.provide(\"config\", compatibilityConfig);\n  return nuxtApp;\n}\nexport async function applyPlugin(nuxtApp, plugin) {\n  if (typeof plugin !== \"function\") {\n    return;\n  }\n  const { provide } = await callWithNuxt(nuxtApp, plugin, [nuxtApp]) || {};\n  if (provide && typeof provide === \"object\") {\n    for (const key in provide) {\n      nuxtApp.provide(key, provide[key]);\n    }\n  }\n}\nexport async function applyPlugins(nuxtApp, plugins) {\n  for (const plugin of plugins) {\n    await applyPlugin(nuxtApp, plugin);\n  }\n}\nexport function normalizePlugins(_plugins) {\n  const unwrappedPlugins = [];\n  const legacyInjectPlugins = [];\n  const invalidPlugins = [];\n  const plugins = _plugins.map((plugin) => {\n    if (typeof plugin !== \"function\") {\n      invalidPlugins.push(plugin);\n      return null;\n    }\n    if (plugin.length > 1) {\n      legacyInjectPlugins.push(plugin);\n      return (nuxtApp) => plugin(nuxtApp, nuxtApp.provide);\n    }\n    if (!isNuxtPlugin(plugin)) {\n      unwrappedPlugins.push(plugin);\n    }\n    return plugin;\n  }).filter(Boolean);\n  if (process.dev && legacyInjectPlugins.length) {\n    console.warn(\"[warn] [nuxt] You are using a plugin with legacy Nuxt 2 format (context, inject) which is likely to be broken. In the future they will be ignored:\", legacyInjectPlugins.map((p) => p.name || p).join(\",\"));\n  }\n  if (process.dev && invalidPlugins.length) {\n    console.warn(\"[warn] [nuxt] Some plugins are not exposing a function and skipped:\", invalidPlugins);\n  }\n  if (process.dev && unwrappedPlugins.length) {\n    console.warn(\"[warn] [nuxt] You are using a plugin that has not been wrapped in `defineNuxtPlugin`. It is advised to wrap your plugins as in the future this may enable enhancements:\", unwrappedPlugins.map((p) => p.name || p).join(\",\"));\n  }\n  return plugins;\n}\nexport function defineNuxtPlugin(plugin) {\n  plugin[NuxtPluginIndicator] = true;\n  return plugin;\n}\nexport function isNuxtPlugin(plugin) {\n  return typeof plugin === \"function\" && NuxtPluginIndicator in plugin;\n}\nexport function callWithNuxt(nuxt, setup, args) {\n  const fn = () => args ? setup(...args) : setup();\n  if (process.server) {\n    return nuxtAppCtx.callAsync(nuxt, fn);\n  } else {\n    nuxtAppCtx.set(nuxt);\n    return fn();\n  }\n}\nexport function useNuxtApp() {\n  const nuxtAppInstance = nuxtAppCtx.tryUse();\n  if (!nuxtAppInstance) {\n    const vm = getCurrentInstance();\n    if (!vm) {\n      throw new Error(\"nuxt instance unavailable\");\n    }\n    return vm.appContext.app.$nuxt;\n  }\n  return nuxtAppInstance;\n}\nexport function useRuntimeConfig() {\n  return useNuxtApp().$config;\n}\nfunction defineGetter(obj, key, val) {\n  Object.defineProperty(obj, key, { get: () => val });\n}\nexport function defineAppConfig(config) {\n  return config;\n}\n", "const n = /[^\\0-\\x7E]/;\nconst t = /[\\x2E\\u3002\\uFF0E\\uFF61]/g;\nconst o = { overflow: \"Overflow Error\", \"not-basic\": \"Illegal Input\", \"invalid-input\": \"Invalid Input\" };\nconst e = Math.floor;\nconst r = String.fromCharCode;\nfunction s(n2) {\n  throw new RangeError(o[n2]);\n}\nconst c = function(n2, t2) {\n  return n2 + 22 + 75 * (n2 < 26) - ((t2 != 0) << 5);\n};\nconst u = function(n2, t2, o2) {\n  let r2 = 0;\n  for (n2 = o2 ? e(n2 / 700) : n2 >> 1, n2 += e(n2 / t2); n2 > 455; r2 += 36) {\n    n2 = e(n2 / 35);\n  }\n  return e(r2 + 36 * n2 / (n2 + 38));\n};\nfunction toASCII(o2) {\n  return function(n2, o3) {\n    const e2 = n2.split(\"@\");\n    let r2 = \"\";\n    e2.length > 1 && (r2 = e2[0] + \"@\", n2 = e2[1]);\n    const s2 = function(n3, t2) {\n      const o4 = [];\n      let e3 = n3.length;\n      for (; e3--; ) {\n        o4[e3] = t2(n3[e3]);\n      }\n      return o4;\n    }((n2 = n2.replace(t, \".\")).split(\".\"), o3).join(\".\");\n    return r2 + s2;\n  }(o2, function(t2) {\n    return n.test(t2) ? \"xn--\" + function(n2) {\n      const t3 = [];\n      const o3 = (n2 = function(n3) {\n        const t4 = [];\n        let o4 = 0;\n        const e2 = n3.length;\n        for (; o4 < e2; ) {\n          const r2 = n3.charCodeAt(o4++);\n          if (r2 >= 55296 && r2 <= 56319 && o4 < e2) {\n            const e3 = n3.charCodeAt(o4++);\n            (64512 & e3) == 56320 ? t4.push(((1023 & r2) << 10) + (1023 & e3) + 65536) : (t4.push(r2), o4--);\n          } else {\n            t4.push(r2);\n          }\n        }\n        return t4;\n      }(n2)).length;\n      let f = 128;\n      let i = 0;\n      let l = 72;\n      for (const o4 of n2) {\n        o4 < 128 && t3.push(r(o4));\n      }\n      const h = t3.length;\n      let p = h;\n      for (h && t3.push(\"-\"); p < o3; ) {\n        let o4 = 2147483647;\n        for (const t4 of n2) {\n          t4 >= f && t4 < o4 && (o4 = t4);\n        }\n        const a = p + 1;\n        o4 - f > e((2147483647 - i) / a) && s(\"overflow\"), i += (o4 - f) * a, f = o4;\n        for (const o5 of n2) {\n          if (o5 < f && ++i > 2147483647 && s(\"overflow\"), o5 == f) {\n            let n3 = i;\n            for (let o6 = 36; ; o6 += 36) {\n              const s2 = o6 <= l ? 1 : o6 >= l + 26 ? 26 : o6 - l;\n              if (n3 < s2) {\n                break;\n              }\n              const u2 = n3 - s2;\n              const f2 = 36 - s2;\n              t3.push(r(c(s2 + u2 % f2, 0))), n3 = e(u2 / f2);\n            }\n            t3.push(r(c(n3, 0))), l = u(i, a, p == h), i = 0, ++p;\n          }\n        }\n        ++i, ++f;\n      }\n      return t3.join(\"\");\n    }(t2) : t2;\n  });\n}\n\nconst HASH_RE = /#/g;\nconst AMPERSAND_RE = /&/g;\nconst SLASH_RE = /\\//g;\nconst EQUAL_RE = /=/g;\nconst IM_RE = /\\?/g;\nconst PLUS_RE = /\\+/g;\nconst ENC_BRACKET_OPEN_RE = /%5b/gi;\nconst ENC_BRACKET_CLOSE_RE = /%5d/gi;\nconst ENC_CARET_RE = /%5e/gi;\nconst ENC_BACKTICK_RE = /%60/gi;\nconst ENC_CURLY_OPEN_RE = /%7b/gi;\nconst ENC_PIPE_RE = /%7c/gi;\nconst ENC_CURLY_CLOSE_RE = /%7d/gi;\nconst ENC_SPACE_RE = /%20/gi;\nconst ENC_SLASH_RE = /%2f/gi;\nconst ENC_ENC_SLASH_RE = /%252f/gi;\nfunction encode(text) {\n  return encodeURI(\"\" + text).replace(ENC_PIPE_RE, \"|\").replace(ENC_BRACKET_OPEN_RE, \"[\").replace(ENC_BRACKET_CLOSE_RE, \"]\");\n}\nfunction encodeHash(text) {\n  return encode(text).replace(ENC_CURLY_OPEN_RE, \"{\").replace(ENC_CURLY_CLOSE_RE, \"}\").replace(ENC_CARET_RE, \"^\");\n}\nfunction encodeQueryValue(text) {\n  return encode(text).replace(PLUS_RE, \"%2B\").replace(ENC_SPACE_RE, \"+\").replace(HASH_RE, \"%23\").replace(AMPERSAND_RE, \"%26\").replace(ENC_BACKTICK_RE, \"`\").replace(ENC_CURLY_OPEN_RE, \"{\").replace(ENC_CURLY_CLOSE_RE, \"}\").replace(ENC_CARET_RE, \"^\");\n}\nfunction encodeQueryKey(text) {\n  return encodeQueryValue(text).replace(EQUAL_RE, \"%3D\");\n}\nfunction encodePath(text) {\n  return encode(text).replace(HASH_RE, \"%23\").replace(IM_RE, \"%3F\").replace(ENC_ENC_SLASH_RE, \"%2F\").replace(AMPERSAND_RE, \"%26\").replace(PLUS_RE, \"%2B\");\n}\nfunction encodeParam(text) {\n  return encodePath(text).replace(SLASH_RE, \"%2F\");\n}\nfunction decode(text = \"\") {\n  try {\n    return decodeURIComponent(\"\" + text);\n  } catch {\n    return \"\" + text;\n  }\n}\nfunction decodePath(text) {\n  return decode(text.replace(ENC_SLASH_RE, \"%252F\"));\n}\nfunction decodeQueryValue(text) {\n  return decode(text.replace(PLUS_RE, \" \"));\n}\nfunction encodeHost(name = \"\") {\n  return toASCII(name);\n}\n\nfunction parseQuery(parametersString = \"\") {\n  const object = {};\n  if (parametersString[0] === \"?\") {\n    parametersString = parametersString.slice(1);\n  }\n  for (const parameter of parametersString.split(\"&\")) {\n    const s = parameter.match(/([^=]+)=?(.*)/) || [];\n    if (s.length < 2) {\n      continue;\n    }\n    const key = decode(s[1]);\n    if (key === \"__proto__\" || key === \"constructor\") {\n      continue;\n    }\n    const value = decodeQueryValue(s[2] || \"\");\n    if (typeof object[key] !== \"undefined\") {\n      if (Array.isArray(object[key])) {\n        object[key].push(value);\n      } else {\n        object[key] = [object[key], value];\n      }\n    } else {\n      object[key] = value;\n    }\n  }\n  return object;\n}\nfunction encodeQueryItem(key, value) {\n  if (typeof value === \"number\" || typeof value === \"boolean\") {\n    value = String(value);\n  }\n  if (!value) {\n    return encodeQueryKey(key);\n  }\n  if (Array.isArray(value)) {\n    return value.map((_value) => `${encodeQueryKey(key)}=${encodeQueryValue(_value)}`).join(\"&\");\n  }\n  return `${encodeQueryKey(key)}=${encodeQueryValue(value)}`;\n}\nfunction stringifyQuery(query) {\n  return Object.keys(query).filter((k) => query[k] !== void 0).map((k) => encodeQueryItem(k, query[k])).join(\"&\");\n}\n\nclass $URL {\n  constructor(input = \"\") {\n    this.query = {};\n    if (typeof input !== \"string\") {\n      throw new TypeError(`URL input should be string received ${typeof input} (${input})`);\n    }\n    const parsed = parseURL(input);\n    this.protocol = decode(parsed.protocol);\n    this.host = decode(parsed.host);\n    this.auth = decode(parsed.auth);\n    this.pathname = decodePath(parsed.pathname);\n    this.query = parseQuery(parsed.search);\n    this.hash = decode(parsed.hash);\n  }\n  get hostname() {\n    return parseHost(this.host).hostname;\n  }\n  get port() {\n    return parseHost(this.host).port || \"\";\n  }\n  get username() {\n    return parseAuth(this.auth).username;\n  }\n  get password() {\n    return parseAuth(this.auth).password || \"\";\n  }\n  get hasProtocol() {\n    return this.protocol.length;\n  }\n  get isAbsolute() {\n    return this.hasProtocol || this.pathname[0] === \"/\";\n  }\n  get search() {\n    const q = stringifyQuery(this.query);\n    return q.length > 0 ? \"?\" + q : \"\";\n  }\n  get searchParams() {\n    const p = new URLSearchParams();\n    for (const name in this.query) {\n      const value = this.query[name];\n      if (Array.isArray(value)) {\n        for (const v of value) {\n          p.append(name, v);\n        }\n      } else {\n        p.append(name, value || \"\");\n      }\n    }\n    return p;\n  }\n  get origin() {\n    return (this.protocol ? this.protocol + \"//\" : \"\") + encodeHost(this.host);\n  }\n  get fullpath() {\n    return encodePath(this.pathname) + this.search + encodeHash(this.hash);\n  }\n  get encodedAuth() {\n    if (!this.auth) {\n      return \"\";\n    }\n    const { username, password } = parseAuth(this.auth);\n    return encodeURIComponent(username) + (password ? \":\" + encodeURIComponent(password) : \"\");\n  }\n  get href() {\n    const auth = this.encodedAuth;\n    const originWithAuth = (this.protocol ? this.protocol + \"//\" : \"\") + (auth ? auth + \"@\" : \"\") + encodeHost(this.host);\n    return this.hasProtocol && this.isAbsolute ? originWithAuth + this.fullpath : this.fullpath;\n  }\n  append(url) {\n    if (url.hasProtocol) {\n      throw new Error(\"Cannot append a URL with protocol\");\n    }\n    Object.assign(this.query, url.query);\n    if (url.pathname) {\n      this.pathname = withTrailingSlash(this.pathname) + withoutLeadingSlash(url.pathname);\n    }\n    if (url.hash) {\n      this.hash = url.hash;\n    }\n  }\n  toJSON() {\n    return this.href;\n  }\n  toString() {\n    return this.href;\n  }\n}\n\nfunction isRelative(inputString) {\n  return [\"./\", \"../\"].some((string_) => inputString.startsWith(string_));\n}\nconst PROTOCOL_REGEX = /^\\w{2,}:(\\/\\/)?/;\nconst PROTOCOL_RELATIVE_REGEX = /^\\/\\/[^/]+/;\nfunction hasProtocol(inputString, acceptProtocolRelative = false) {\n  return PROTOCOL_REGEX.test(inputString) || acceptProtocolRelative && PROTOCOL_RELATIVE_REGEX.test(inputString);\n}\nconst TRAILING_SLASH_RE = /\\/$|\\/\\?/;\nfunction hasTrailingSlash(input = \"\", queryParameters = false) {\n  if (!queryParameters) {\n    return input.endsWith(\"/\");\n  }\n  return TRAILING_SLASH_RE.test(input);\n}\nfunction withoutTrailingSlash(input = \"\", queryParameters = false) {\n  if (!queryParameters) {\n    return (hasTrailingSlash(input) ? input.slice(0, -1) : input) || \"/\";\n  }\n  if (!hasTrailingSlash(input, true)) {\n    return input || \"/\";\n  }\n  const [s0, ...s] = input.split(\"?\");\n  return (s0.slice(0, -1) || \"/\") + (s.length > 0 ? `?${s.join(\"?\")}` : \"\");\n}\nfunction withTrailingSlash(input = \"\", queryParameters = false) {\n  if (!queryParameters) {\n    return input.endsWith(\"/\") ? input : input + \"/\";\n  }\n  if (hasTrailingSlash(input, true)) {\n    return input || \"/\";\n  }\n  const [s0, ...s] = input.split(\"?\");\n  return s0 + \"/\" + (s.length > 0 ? `?${s.join(\"?\")}` : \"\");\n}\nfunction hasLeadingSlash(input = \"\") {\n  return input.startsWith(\"/\");\n}\nfunction withoutLeadingSlash(input = \"\") {\n  return (hasLeadingSlash(input) ? input.slice(1) : input) || \"/\";\n}\nfunction withLeadingSlash(input = \"\") {\n  return hasLeadingSlash(input) ? input : \"/\" + input;\n}\nfunction cleanDoubleSlashes(input = \"\") {\n  return input.split(\"://\").map((string_) => string_.replace(/\\/{2,}/g, \"/\")).join(\"://\");\n}\nfunction withBase(input, base) {\n  if (isEmptyURL(base) || hasProtocol(input)) {\n    return input;\n  }\n  const _base = withoutTrailingSlash(base);\n  if (input.startsWith(_base)) {\n    return input;\n  }\n  return joinURL(_base, input);\n}\nfunction withoutBase(input, base) {\n  if (isEmptyURL(base)) {\n    return input;\n  }\n  const _base = withoutTrailingSlash(base);\n  if (!input.startsWith(_base)) {\n    return input;\n  }\n  const trimmed = input.slice(_base.length);\n  return trimmed[0] === \"/\" ? trimmed : \"/\" + trimmed;\n}\nfunction withQuery(input, query) {\n  const parsed = parseURL(input);\n  const mergedQuery = { ...parseQuery(parsed.search), ...query };\n  parsed.search = stringifyQuery(mergedQuery);\n  return stringifyParsedURL(parsed);\n}\nfunction getQuery(input) {\n  return parseQuery(parseURL(input).search);\n}\nfunction isEmptyURL(url) {\n  return !url || url === \"/\";\n}\nfunction isNonEmptyURL(url) {\n  return url && url !== \"/\";\n}\nfunction joinURL(base, ...input) {\n  let url = base || \"\";\n  for (const index of input.filter((url2) => isNonEmptyURL(url2))) {\n    url = url ? withTrailingSlash(url) + withoutLeadingSlash(index) : index;\n  }\n  return url;\n}\nfunction withHttp(input) {\n  return withProtocol(input, \"http://\");\n}\nfunction withHttps(input) {\n  return withProtocol(input, \"https://\");\n}\nfunction withoutProtocol(input) {\n  return withProtocol(input, \"\");\n}\nfunction withProtocol(input, protocol) {\n  const match = input.match(PROTOCOL_REGEX);\n  if (!match) {\n    return protocol + input;\n  }\n  return protocol + input.slice(match[0].length);\n}\nfunction createURL(input) {\n  return new $URL(input);\n}\nfunction normalizeURL(input) {\n  return createURL(input).toString();\n}\nfunction resolveURL(base, ...input) {\n  const url = createURL(base);\n  for (const index of input.filter((url2) => isNonEmptyURL(url2))) {\n    url.append(createURL(index));\n  }\n  return url.toString();\n}\nfunction isSamePath(p1, p2) {\n  return decode(withoutTrailingSlash(p1)) === decode(withoutTrailingSlash(p2));\n}\nfunction isEqual(a, b, options = {}) {\n  if (!options.trailingSlash) {\n    a = withTrailingSlash(a);\n    b = withTrailingSlash(b);\n  }\n  if (!options.leadingSlash) {\n    a = withLeadingSlash(a);\n    b = withLeadingSlash(b);\n  }\n  if (!options.encoding) {\n    a = decode(a);\n    b = decode(b);\n  }\n  return a === b;\n}\n\nfunction parseURL(input = \"\", defaultProto) {\n  if (!hasProtocol(input, true)) {\n    return defaultProto ? parseURL(defaultProto + input) : parsePath(input);\n  }\n  const [protocol = \"\", auth, hostAndPath = \"\"] = (input.replace(/\\\\/g, \"/\").match(/([^/:]+:)?\\/\\/([^/@]+@)?(.*)/) || []).splice(1);\n  const [host = \"\", path = \"\"] = (hostAndPath.match(/([^#/?]*)(.*)?/) || []).splice(1);\n  const { pathname, search, hash } = parsePath(path.replace(/\\/(?=[A-Za-z]:)/, \"\"));\n  return {\n    protocol,\n    auth: auth ? auth.slice(0, Math.max(0, auth.length - 1)) : \"\",\n    host,\n    pathname,\n    search,\n    hash\n  };\n}\nfunction parsePath(input = \"\") {\n  const [pathname = \"\", search = \"\", hash = \"\"] = (input.match(/([^#?]*)(\\?[^#]*)?(#.*)?/) || []).splice(1);\n  return {\n    pathname,\n    search,\n    hash\n  };\n}\nfunction parseAuth(input = \"\") {\n  const [username, password] = input.split(\":\");\n  return {\n    username: decode(username),\n    password: decode(password)\n  };\n}\nfunction parseHost(input = \"\") {\n  const [hostname, port] = (input.match(/([^/]*)(:0-9+)?/) || []).splice(1);\n  return {\n    hostname: decode(hostname),\n    port\n  };\n}\nfunction stringifyParsedURL(parsed) {\n  const fullpath = parsed.pathname + (parsed.search ? (parsed.search.startsWith(\"?\") ? \"\" : \"?\") + parsed.search : \"\") + parsed.hash;\n  if (!parsed.protocol) {\n    return fullpath;\n  }\n  return parsed.protocol + \"//\" + (parsed.auth ? parsed.auth + \"@\" : \"\") + parsed.host + fullpath;\n}\n\nexport { $URL, cleanDoubleSlashes, createURL, decode, decodePath, decodeQueryValue, encode, encodeHash, encodeHost, encodeParam, encodePath, encodeQueryItem, encodeQueryKey, encodeQueryValue, getQuery, hasLeadingSlash, hasProtocol, hasTrailingSlash, isEmptyURL, isEqual, isNonEmptyURL, isRelative, isSamePath, joinURL, normalizeURL, parseAuth, parseHost, parsePath, parseQuery, parseURL, resolveURL, stringifyParsedURL, stringifyQuery, withBase, withHttp, withHttps, withLeadingSlash, withProtocol, withQuery, withTrailingSlash, withoutBase, withoutLeadingSlash, withoutProtocol, withoutTrailingSlash };\n", "const suspectProtoRx = /\"(?:_|\\\\u0{2}5[Ff]){2}(?:p|\\\\u0{2}70)(?:r|\\\\u0{2}72)(?:o|\\\\u0{2}6[Ff])(?:t|\\\\u0{2}74)(?:o|\\\\u0{2}6[Ff])(?:_|\\\\u0{2}5[Ff]){2}\"\\s*:/;\nconst suspectConstructorRx = /\"(?:c|\\\\u0063)(?:o|\\\\u006[Ff])(?:n|\\\\u006[Ee])(?:s|\\\\u0073)(?:t|\\\\u0074)(?:r|\\\\u0072)(?:u|\\\\u0075)(?:c|\\\\u0063)(?:t|\\\\u0074)(?:o|\\\\u006[Ff])(?:r|\\\\u0072)\"\\s*:/;\nconst JsonSigRx = /^\\s*[\"[{]|^\\s*-?\\d[\\d.]{0,14}\\s*$/;\nfunction jsonParseTransform(key, value) {\n  if (key === \"__proto__\") {\n    return;\n  }\n  if (key === \"constructor\" && value && typeof value === \"object\" && \"prototype\" in value) {\n    return;\n  }\n  return value;\n}\nfunction destr(value, options = {}) {\n  if (typeof value !== \"string\") {\n    return value;\n  }\n  const _lval = value.toLowerCase().trim();\n  if (_lval === \"true\") {\n    return true;\n  }\n  if (_lval === \"false\") {\n    return false;\n  }\n  if (_lval === \"null\") {\n    return null;\n  }\n  if (_lval === \"nan\") {\n    return Number.NaN;\n  }\n  if (_lval === \"infinity\") {\n    return Number.POSITIVE_INFINITY;\n  }\n  if (_lval === \"undefined\") {\n    return void 0;\n  }\n  if (!JsonSigRx.test(value)) {\n    if (options.strict) {\n      throw new SyntaxError(\"Invalid JSON\");\n    }\n    return value;\n  }\n  try {\n    if (suspectProtoRx.test(value) || suspectConstructorRx.test(value)) {\n      return JSON.parse(value, jsonParseTransform);\n    }\n    return JSON.parse(value);\n  } catch (error) {\n    if (options.strict) {\n      throw error;\n    }\n    return value;\n  }\n}\n\nexport { destr as default };\n", "const decode = decodeURIComponent;\nconst encode = encodeURIComponent;\nconst pairSplitRegExp = /; */;\nconst fieldContentRegExp = /^[\\u0009\\u0020-\\u007e\\u0080-\\u00ff]+$/;\nfunction parse(str, options) {\n  if (typeof str !== \"string\") {\n    throw new TypeError(\"argument str must be a string\");\n  }\n  let obj = {};\n  let opt = options || {};\n  let pairs = str.split(pairSplitRegExp);\n  let dec = opt.decode || decode;\n  for (let i = 0; i < pairs.length; i++) {\n    let pair = pairs[i];\n    let eq_idx = pair.indexOf(\"=\");\n    if (eq_idx < 0) {\n      continue;\n    }\n    let key = pair.substr(0, eq_idx).trim();\n    let val = pair.substr(++eq_idx, pair.length).trim();\n    if (val[0] == '\"') {\n      val = val.slice(1, -1);\n    }\n    if (obj[key] == void 0) {\n      obj[key] = tryDecode(val, dec);\n    }\n  }\n  return obj;\n}\nfunction serialize(name, value, options) {\n  let opt = options || {};\n  let enc = opt.encode || encode;\n  if (typeof enc !== \"function\") {\n    throw new TypeError(\"option encode is invalid\");\n  }\n  if (!fieldContentRegExp.test(name)) {\n    throw new TypeError(\"argument name is invalid\");\n  }\n  let encodedValue = enc(value);\n  if (encodedValue && !fieldContentRegExp.test(encodedValue)) {\n    throw new TypeError(\"argument val is invalid\");\n  }\n  let str = name + \"=\" + encodedValue;\n  if (opt.maxAge != null) {\n    let maxAge = opt.maxAge - 0;\n    if (isNaN(maxAge) || !isFinite(maxAge)) {\n      throw new TypeError(\"option maxAge is invalid\");\n    }\n    str += \"; Max-Age=\" + Math.floor(maxAge);\n  }\n  if (opt.domain) {\n    if (!fieldContentRegExp.test(opt.domain)) {\n      throw new TypeError(\"option domain is invalid\");\n    }\n    str += \"; Domain=\" + opt.domain;\n  }\n  if (opt.path) {\n    if (!fieldContentRegExp.test(opt.path)) {\n      throw new TypeError(\"option path is invalid\");\n    }\n    str += \"; Path=\" + opt.path;\n  }\n  if (opt.expires) {\n    if (typeof opt.expires.toUTCString !== \"function\") {\n      throw new TypeError(\"option expires is invalid\");\n    }\n    str += \"; Expires=\" + opt.expires.toUTCString();\n  }\n  if (opt.httpOnly) {\n    str += \"; HttpOnly\";\n  }\n  if (opt.secure) {\n    str += \"; Secure\";\n  }\n  if (opt.sameSite) {\n    let sameSite = typeof opt.sameSite === \"string\" ? opt.sameSite.toLowerCase() : opt.sameSite;\n    switch (sameSite) {\n      case true:\n        str += \"; SameSite=Strict\";\n        break;\n      case \"lax\":\n        str += \"; SameSite=Lax\";\n        break;\n      case \"strict\":\n        str += \"; SameSite=Strict\";\n        break;\n      case \"none\":\n        str += \"; SameSite=None\";\n        break;\n      default:\n        throw new TypeError(\"option sameSite is invalid\");\n    }\n  }\n  return str;\n}\nfunction tryDecode(str, decode2) {\n  try {\n    return decode2(str);\n  } catch (e) {\n    return str;\n  }\n}\n\nexport { parse, serialize };\n", "import { withoutTrailingSlash, withoutBase, getQuery as getQuery$1 } from 'ufo';\nimport { createRouter as createRouter$1 } from 'radix3';\nimport destr from 'destr';\nimport { parse as parse$1, serialize } from 'cookie-es';\n\nfunction useBase(base, handler) {\n  base = withoutTrailingSlash(base);\n  if (!base) {\n    return handler;\n  }\n  return eventHandler((event) => {\n    event.node.req.originalUrl = event.node.req.originalUrl || event.node.req.url || \"/\";\n    event.node.req.url = withoutBase(event.node.req.url || \"/\", base);\n    return handler(event);\n  });\n}\n\nfunction parse(multipartBodyBuffer, boundary) {\n  let lastline = \"\";\n  let state = 0 /* INIT */;\n  let buffer = [];\n  const allParts = [];\n  let currentPartHeaders = [];\n  for (let i = 0; i < multipartBodyBuffer.length; i++) {\n    const prevByte = i > 0 ? multipartBodyBuffer[i - 1] : null;\n    const currByte = multipartBodyBuffer[i];\n    const newLineChar = currByte === 10 || currByte === 13;\n    if (!newLineChar) {\n      lastline += String.fromCodePoint(currByte);\n    }\n    const newLineDetected = currByte === 10 && prevByte === 13;\n    if (0 /* INIT */ === state && newLineDetected) {\n      if (\"--\" + boundary === lastline) {\n        state = 1 /* READING_HEADERS */;\n      }\n      lastline = \"\";\n    } else if (1 /* READING_HEADERS */ === state && newLineDetected) {\n      if (lastline.length > 0) {\n        const i2 = lastline.indexOf(\":\");\n        if (i2 > 0) {\n          const name = lastline.slice(0, i2).toLowerCase();\n          const value = lastline.slice(i2 + 1).trim();\n          currentPartHeaders.push([name, value]);\n        }\n      } else {\n        state = 2 /* READING_DATA */;\n        buffer = [];\n      }\n      lastline = \"\";\n    } else if (2 /* READING_DATA */ === state) {\n      if (lastline.length > boundary.length + 4) {\n        lastline = \"\";\n      }\n      if (\"--\" + boundary === lastline) {\n        const j = buffer.length - lastline.length;\n        const part = buffer.slice(0, j - 1);\n        allParts.push(process(part, currentPartHeaders));\n        buffer = [];\n        currentPartHeaders = [];\n        lastline = \"\";\n        state = 3 /* READING_PART_SEPARATOR */;\n      } else {\n        buffer.push(currByte);\n      }\n      if (newLineDetected) {\n        lastline = \"\";\n      }\n    } else if (3 /* READING_PART_SEPARATOR */ === state && newLineDetected) {\n      state = 1 /* READING_HEADERS */;\n    }\n  }\n  return allParts;\n}\nfunction process(data, headers) {\n  const dataObj = {};\n  const contentDispositionHeader = headers.find((h) => h[0] === \"content-disposition\")?.[1] || \"\";\n  for (const i of contentDispositionHeader.split(\";\")) {\n    const s = i.split(\"=\");\n    if (s.length !== 2) {\n      continue;\n    }\n    const key = (s[0] || \"\").trim();\n    if (key === \"name\" || key === \"filename\") {\n      dataObj[key] = (s[1] || \"\").trim().replace(/\"/g, \"\");\n    }\n  }\n  const contentType = headers.find((h) => h[0] === \"content-type\")?.[1] || \"\";\n  if (contentType) {\n    dataObj.type = contentType;\n  }\n  dataObj.data = Buffer.from(data);\n  return dataObj;\n}\n\nclass H3Error extends Error {\n  constructor() {\n    super(...arguments);\n    this.statusCode = 500;\n    this.fatal = false;\n    this.unhandled = false;\n    this.statusMessage = void 0;\n  }\n  toJSON() {\n    const obj = {\n      message: this.message,\n      statusCode: this.statusCode\n    };\n    if (this.statusMessage) {\n      obj.statusMessage = this.statusMessage;\n    }\n    if (this.data !== void 0) {\n      obj.data = this.data;\n    }\n    return obj;\n  }\n}\nH3Error.__h3_error__ = true;\nfunction createError(input) {\n  if (typeof input === \"string\") {\n    return new H3Error(input);\n  }\n  if (isError(input)) {\n    return input;\n  }\n  const err = new H3Error(\n    input.message ?? input.statusMessage,\n    // @ts-ignore\n    input.cause ? { cause: input.cause } : void 0\n  );\n  if (\"stack\" in input) {\n    try {\n      Object.defineProperty(err, \"stack\", {\n        get() {\n          return input.stack;\n        }\n      });\n    } catch {\n      try {\n        err.stack = input.stack;\n      } catch {\n      }\n    }\n  }\n  if (input.data) {\n    err.data = input.data;\n  }\n  if (input.statusCode) {\n    err.statusCode = input.statusCode;\n  } else if (input.status) {\n    err.statusCode = input.status;\n  }\n  if (input.statusMessage) {\n    err.statusMessage = input.statusMessage;\n  } else if (input.statusText) {\n    err.statusMessage = input.statusText;\n  }\n  if (input.fatal !== void 0) {\n    err.fatal = input.fatal;\n  }\n  if (input.unhandled !== void 0) {\n    err.unhandled = input.unhandled;\n  }\n  return err;\n}\nfunction sendError(event, error, debug) {\n  if (event.node.res.writableEnded) {\n    return;\n  }\n  const h3Error = isError(error) ? error : createError(error);\n  const responseBody = {\n    statusCode: h3Error.statusCode,\n    statusMessage: h3Error.statusMessage,\n    stack: [],\n    data: h3Error.data\n  };\n  if (debug) {\n    responseBody.stack = (h3Error.stack || \"\").split(\"\\n\").map((l) => l.trim());\n  }\n  if (event.node.res.writableEnded) {\n    return;\n  }\n  const _code = Number.parseInt(h3Error.statusCode);\n  if (_code) {\n    event.node.res.statusCode = _code;\n  }\n  if (h3Error.statusMessage) {\n    event.node.res.statusMessage = h3Error.statusMessage;\n  }\n  event.node.res.setHeader(\"content-type\", MIMES.json);\n  event.node.res.end(JSON.stringify(responseBody, void 0, 2));\n}\nfunction isError(input) {\n  return input?.constructor?.__h3_error__ === true;\n}\n\nfunction getQuery(event) {\n  return getQuery$1(event.node.req.url || \"\");\n}\nfunction getRouterParams(event) {\n  return event.context.params || {};\n}\nfunction getRouterParam(event, name) {\n  const params = getRouterParams(event);\n  return params[name];\n}\nfunction getMethod(event, defaultMethod = \"GET\") {\n  return (event.node.req.method || defaultMethod).toUpperCase();\n}\nfunction isMethod(event, expected, allowHead) {\n  const method = getMethod(event);\n  if (allowHead && method === \"HEAD\") {\n    return true;\n  }\n  if (typeof expected === \"string\") {\n    if (method === expected) {\n      return true;\n    }\n  } else if (expected.includes(method)) {\n    return true;\n  }\n  return false;\n}\nfunction assertMethod(event, expected, allowHead) {\n  if (!isMethod(event, expected, allowHead)) {\n    throw createError({\n      statusCode: 405,\n      statusMessage: \"HTTP method is not allowed.\"\n    });\n  }\n}\nfunction getRequestHeaders(event) {\n  const _headers = {};\n  for (const key in event.node.req.headers) {\n    const val = event.node.req.headers[key];\n    _headers[key] = Array.isArray(val) ? val.filter(Boolean).join(\", \") : val;\n  }\n  return _headers;\n}\nconst getHeaders = getRequestHeaders;\nfunction getRequestHeader(event, name) {\n  const headers = getRequestHeaders(event);\n  const value = headers[name.toLowerCase()];\n  return value;\n}\nconst getHeader = getRequestHeader;\n\nconst RawBodySymbol = Symbol.for(\"h3RawBody\");\nconst ParsedBodySymbol = Symbol.for(\"h3ParsedBody\");\nconst PayloadMethods$1 = [\"PATCH\", \"POST\", \"PUT\", \"DELETE\"];\nfunction readRawBody(event, encoding = \"utf8\") {\n  assertMethod(event, PayloadMethods$1);\n  if (RawBodySymbol in event.node.req) {\n    const promise2 = Promise.resolve(event.node.req[RawBodySymbol]);\n    return encoding ? promise2.then((buff) => buff.toString(encoding)) : promise2;\n  }\n  if (\"body\" in event.node.req) {\n    return Promise.resolve(event.node.req.body);\n  }\n  if (!Number.parseInt(event.node.req.headers[\"content-length\"] || \"\")) {\n    return Promise.resolve(void 0);\n  }\n  const promise = event.node.req[RawBodySymbol] = new Promise(\n    (resolve, reject) => {\n      const bodyData = [];\n      event.node.req.on(\"error\", (err) => {\n        reject(err);\n      }).on(\"data\", (chunk) => {\n        bodyData.push(chunk);\n      }).on(\"end\", () => {\n        resolve(Buffer.concat(bodyData));\n      });\n    }\n  );\n  const result = encoding ? promise.then((buff) => buff.toString(encoding)) : promise;\n  return result;\n}\nasync function readBody(event) {\n  if (ParsedBodySymbol in event.node.req) {\n    return event.node.req[ParsedBodySymbol];\n  }\n  const body = await readRawBody(event);\n  if (event.node.req.headers[\"content-type\"] === \"application/x-www-form-urlencoded\") {\n    const form = new URLSearchParams(body);\n    const parsedForm = /* @__PURE__ */ Object.create(null);\n    for (const [key, value] of form.entries()) {\n      if (key in parsedForm) {\n        if (!Array.isArray(parsedForm[key])) {\n          parsedForm[key] = [parsedForm[key]];\n        }\n        parsedForm[key].push(value);\n      } else {\n        parsedForm[key] = value;\n      }\n    }\n    return parsedForm;\n  }\n  const json = destr(body);\n  event.node.req[ParsedBodySymbol] = json;\n  return json;\n}\nasync function readMultipartFormData(event) {\n  const contentType = getRequestHeader(event, \"content-type\");\n  if (!contentType || !contentType.startsWith(\"multipart/form-data\")) {\n    return;\n  }\n  const boundary = contentType.match(/boundary=([^;]*)(;|$)/i)?.[1];\n  if (!boundary) {\n    return;\n  }\n  const body = await readRawBody(event, false);\n  if (!body) {\n    return;\n  }\n  return parse(body, boundary);\n}\n\nfunction handleCacheHeaders(event, opts) {\n  const cacheControls = [\"public\", ...opts.cacheControls || []];\n  let cacheMatched = false;\n  if (opts.maxAge !== void 0) {\n    cacheControls.push(`max-age=${+opts.maxAge}`, `s-maxage=${+opts.maxAge}`);\n  }\n  if (opts.modifiedTime) {\n    const modifiedTime = new Date(opts.modifiedTime);\n    const ifModifiedSince = event.node.req.headers[\"if-modified-since\"];\n    event.node.res.setHeader(\"last-modified\", modifiedTime.toUTCString());\n    if (ifModifiedSince && new Date(ifModifiedSince) >= opts.modifiedTime) {\n      cacheMatched = true;\n    }\n  }\n  if (opts.etag) {\n    event.node.res.setHeader(\"etag\", opts.etag);\n    const ifNonMatch = event.node.req.headers[\"if-none-match\"];\n    if (ifNonMatch === opts.etag) {\n      cacheMatched = true;\n    }\n  }\n  event.node.res.setHeader(\"cache-control\", cacheControls.join(\", \"));\n  if (cacheMatched) {\n    event.node.res.statusCode = 304;\n    event.node.res.end();\n    return true;\n  }\n  return false;\n}\n\nconst MIMES = {\n  html: \"text/html\",\n  json: \"application/json\"\n};\n\nconst defer = typeof setImmediate !== \"undefined\" ? setImmediate : (fn) => fn();\nfunction send(event, data, type) {\n  if (type) {\n    defaultContentType(event, type);\n  }\n  return new Promise((resolve) => {\n    defer(() => {\n      event.node.res.end(data);\n      resolve();\n    });\n  });\n}\nfunction sendNoContent(event, code = 204) {\n  event.node.res.statusCode = code;\n  if (event.node.res.statusCode === 204) {\n    event.node.res.removeHeader(\"content-length\");\n  }\n  event.node.res.end();\n}\nfunction setResponseStatus(event, code, text) {\n  event.node.res.statusCode = code;\n  if (text) {\n    event.node.res.statusMessage = text;\n  }\n}\nfunction getResponseStatus(event) {\n  return event.node.res.statusCode;\n}\nfunction getResponseStatusText(event) {\n  return event.node.res.statusMessage;\n}\nfunction defaultContentType(event, type) {\n  if (type && !event.node.res.getHeader(\"content-type\")) {\n    event.node.res.setHeader(\"content-type\", type);\n  }\n}\nfunction sendRedirect(event, location, code = 302) {\n  event.node.res.statusCode = code;\n  event.node.res.setHeader(\"location\", location);\n  const encodedLoc = location.replace(/\"/g, \"%22\");\n  const html = `<!DOCTYPE html><html><head><meta http-equiv=\"refresh\" content=\"0; url=${encodedLoc}\"></head></html>`;\n  return send(event, html, MIMES.html);\n}\nfunction getResponseHeaders(event) {\n  return event.node.res.getHeaders();\n}\nfunction getResponseHeader(event, name) {\n  return event.node.res.getHeader(name);\n}\nfunction setResponseHeaders(event, headers) {\n  for (const [name, value] of Object.entries(headers)) {\n    event.node.res.setHeader(name, value);\n  }\n}\nconst setHeaders = setResponseHeaders;\nfunction setResponseHeader(event, name, value) {\n  event.node.res.setHeader(name, value);\n}\nconst setHeader = setResponseHeader;\nfunction appendResponseHeaders(event, headers) {\n  for (const [name, value] of Object.entries(headers)) {\n    appendResponseHeader(event, name, value);\n  }\n}\nconst appendHeaders = appendResponseHeaders;\nfunction appendResponseHeader(event, name, value) {\n  let current = event.node.res.getHeader(name);\n  if (!current) {\n    event.node.res.setHeader(name, value);\n    return;\n  }\n  if (!Array.isArray(current)) {\n    current = [current.toString()];\n  }\n  event.node.res.setHeader(name, [...current, value]);\n}\nconst appendHeader = appendResponseHeader;\nfunction isStream(data) {\n  return data && typeof data === \"object\" && typeof data.pipe === \"function\" && typeof data.on === \"function\";\n}\nfunction sendStream(event, data) {\n  return new Promise((resolve, reject) => {\n    data.pipe(event.node.res);\n    data.on(\"end\", () => resolve());\n    data.on(\"error\", (error) => reject(createError(error)));\n  });\n}\nconst noop = () => {\n};\nfunction writeEarlyHints(event, hints, cb = noop) {\n  if (!event.node.res.socket) {\n    cb();\n    return;\n  }\n  if (typeof hints === \"string\" || Array.isArray(hints)) {\n    hints = { link: hints };\n  }\n  if (hints.link) {\n    hints.link = Array.isArray(hints.link) ? hints.link : hints.link.split(\",\");\n  }\n  const headers = Object.entries(hints).map(\n    (e) => [e[0].toLowerCase(), e[1]]\n  );\n  if (headers.length === 0) {\n    cb();\n    return;\n  }\n  let hint = \"HTTP/1.1 103 Early Hints\";\n  if (hints.link) {\n    hint += `\\r\nLink: ${hints.link.join(\", \")}`;\n  }\n  for (const [header, value] of headers) {\n    if (header === \"link\") {\n      continue;\n    }\n    hint += `\\r\n${header}: ${value}`;\n  }\n  if (event.node.res.socket) {\n    event.node.res.socket.write(\n      `${hint}\\r\n\\r\n`,\n      \"utf8\",\n      cb\n    );\n  } else {\n    cb();\n  }\n}\n\nfunction parseCookies(event) {\n  return parse$1(event.node.req.headers.cookie || \"\");\n}\nfunction getCookie(event, name) {\n  return parseCookies(event)[name];\n}\nfunction setCookie(event, name, value, serializeOptions) {\n  const cookieStr = serialize(name, value, {\n    path: \"/\",\n    ...serializeOptions\n  });\n  appendHeader(event, \"Set-Cookie\", cookieStr);\n}\nfunction deleteCookie(event, name, serializeOptions) {\n  setCookie(event, name, \"\", {\n    ...serializeOptions,\n    maxAge: 0\n  });\n}\n\nconst PayloadMethods = /* @__PURE__ */ new Set([\"PATCH\", \"POST\", \"PUT\", \"DELETE\"]);\nconst ignoredHeaders = /* @__PURE__ */ new Set([\n  \"transfer-encoding\",\n  \"connection\",\n  \"keep-alive\",\n  \"upgrade\",\n  \"expect\"\n]);\nasync function proxyRequest(event, target, opts = {}) {\n  const method = getMethod(event);\n  let body;\n  if (PayloadMethods.has(method)) {\n    body = await readRawBody(event).catch(() => void 0);\n  }\n  const headers = /* @__PURE__ */ Object.create(null);\n  const reqHeaders = getRequestHeaders(event);\n  for (const name in reqHeaders) {\n    if (!ignoredHeaders.has(name)) {\n      headers[name] = reqHeaders[name];\n    }\n  }\n  if (opts.fetchOptions?.headers) {\n    Object.assign(headers, opts.fetchOptions.headers);\n  }\n  if (opts.headers) {\n    Object.assign(headers, opts.headers);\n  }\n  return sendProxy(event, target, {\n    ...opts,\n    fetchOptions: {\n      headers,\n      method,\n      body,\n      ...opts.fetchOptions\n    }\n  });\n}\nasync function sendProxy(event, target, opts = {}) {\n  const _fetch = opts.fetch || globalThis.fetch;\n  if (!_fetch) {\n    throw new Error(\n      \"fetch is not available. Try importing `node-fetch-native/polyfill` for Node.js.\"\n    );\n  }\n  const response = await _fetch(target, {\n    headers: opts.headers,\n    ...opts.fetchOptions\n  });\n  event.node.res.statusCode = response.status;\n  event.node.res.statusMessage = response.statusText;\n  for (const [key, value] of response.headers.entries()) {\n    if (key === \"content-encoding\") {\n      continue;\n    }\n    if (key === \"content-length\") {\n      continue;\n    }\n    event.node.res.setHeader(key, value);\n  }\n  try {\n    if (response.body) {\n      if (opts.sendStream === false) {\n        const data = new Uint8Array(await response.arrayBuffer());\n        event.node.res.end(data);\n      } else {\n        for await (const chunk of response.body) {\n          event.node.res.write(chunk);\n        }\n        event.node.res.end();\n      }\n    }\n  } catch (error) {\n    event.node.res.end();\n    throw error;\n  }\n}\n\nclass H3Headers {\n  constructor(init) {\n    if (!init) {\n      this._headers = {};\n    } else if (Array.isArray(init)) {\n      this._headers = Object.fromEntries(\n        init.map(([key, value]) => [key.toLowerCase(), value])\n      );\n    } else if (init && \"append\" in init) {\n      this._headers = Object.fromEntries(init.entries());\n    } else {\n      this._headers = Object.fromEntries(\n        Object.entries(init).map(([key, value]) => [key.toLowerCase(), value])\n      );\n    }\n  }\n  [Symbol.iterator]() {\n    return this.entries();\n  }\n  entries() {\n    throw Object.entries(this._headers)[Symbol.iterator]();\n  }\n  keys() {\n    return Object.keys(this._headers)[Symbol.iterator]();\n  }\n  values() {\n    throw Object.values(this._headers)[Symbol.iterator]();\n  }\n  append(name, value) {\n    const _name = name.toLowerCase();\n    this.set(_name, [this.get(_name), value].filter(Boolean).join(\", \"));\n  }\n  delete(name) {\n    delete this._headers[name.toLowerCase()];\n  }\n  get(name) {\n    return this._headers[name.toLowerCase()];\n  }\n  has(name) {\n    return name.toLowerCase() in this._headers;\n  }\n  set(name, value) {\n    this._headers[name.toLowerCase()] = String(value);\n  }\n  forEach(callbackfn) {\n    for (const [key, value] of Object.entries(this._headers)) {\n      callbackfn(value, key, this);\n    }\n  }\n}\n\nclass H3Response {\n  constructor(body = null, init = {}) {\n    // TODO: yet to implement\n    this.body = null;\n    this.type = \"default\";\n    this.bodyUsed = false;\n    this.headers = new H3Headers(init.headers);\n    this.status = init.status ?? 200;\n    this.statusText = init.statusText || \"\";\n    this.redirected = !!init.status && [301, 302, 307, 308].includes(init.status);\n    this._body = body;\n    this.url = \"\";\n    this.ok = this.status < 300 && this.status > 199;\n  }\n  clone() {\n    return new H3Response(this.body, {\n      headers: this.headers,\n      status: this.status,\n      statusText: this.statusText\n    });\n  }\n  arrayBuffer() {\n    return Promise.resolve(this._body);\n  }\n  blob() {\n    return Promise.resolve(this._body);\n  }\n  formData() {\n    return Promise.resolve(this._body);\n  }\n  json() {\n    return Promise.resolve(this._body);\n  }\n  text() {\n    return Promise.resolve(this._body);\n  }\n}\n\nclass H3Event {\n  constructor(req, res) {\n    this[\"__is_event__\"] = true;\n    this.context = {};\n    this.node = { req, res };\n  }\n  get path() {\n    return this.req.url;\n  }\n  /** @deprecated Please use `event.node.req` instead. **/\n  get req() {\n    return this.node.req;\n  }\n  /** @deprecated Please use `event.node.res` instead. **/\n  get res() {\n    return this.node.res;\n  }\n  // Implementation of FetchEvent\n  respondWith(r) {\n    Promise.resolve(r).then((_response) => {\n      if (this.res.writableEnded) {\n        return;\n      }\n      const response = _response instanceof H3Response ? _response : new H3Response(_response);\n      for (const [key, value] of response.headers.entries()) {\n        this.res.setHeader(key, value);\n      }\n      if (response.status) {\n        this.res.statusCode = response.status;\n      }\n      if (response.statusText) {\n        this.res.statusMessage = response.statusText;\n      }\n      if (response.redirected) {\n        this.res.setHeader(\"location\", response.url);\n      }\n      if (!response._body) {\n        return this.res.end();\n      }\n      if (typeof response._body === \"string\" || \"buffer\" in response._body || \"byteLength\" in response._body) {\n        return this.res.end(response._body);\n      }\n      if (!response.headers.has(\"content-type\")) {\n        response.headers.set(\"content-type\", MIMES.json);\n      }\n      this.res.end(JSON.stringify(response._body));\n    });\n  }\n}\nfunction isEvent(input) {\n  return \"__is_event__\" in input;\n}\nfunction createEvent(req, res) {\n  return new H3Event(req, res);\n}\n\nfunction defineEventHandler(handler) {\n  handler.__is_handler__ = true;\n  return handler;\n}\nconst eventHandler = defineEventHandler;\nfunction isEventHandler(input) {\n  return \"__is_handler__\" in input;\n}\nfunction toEventHandler(input, _, _route) {\n  if (!isEventHandler(input)) {\n    console.warn(\n      \"[h3] Implicit event handler conversion is deprecated. Use `eventHandler()` or `fromNodeMiddleware()` to define event handlers.\",\n      _route && _route !== \"/\" ? `\n     Route: ${_route}` : \"\",\n      `\n     Handler: ${input}`\n    );\n  }\n  return input;\n}\nfunction dynamicEventHandler(initial) {\n  let current = initial;\n  const wrapper = eventHandler((event) => {\n    if (current) {\n      return current(event);\n    }\n  });\n  wrapper.set = (handler) => {\n    current = handler;\n  };\n  return wrapper;\n}\nfunction defineLazyEventHandler(factory) {\n  let _promise;\n  let _resolved;\n  const resolveHandler = () => {\n    if (_resolved) {\n      return Promise.resolve(_resolved);\n    }\n    if (!_promise) {\n      _promise = Promise.resolve(factory()).then((r) => {\n        const handler = r.default || r;\n        if (typeof handler !== \"function\") {\n          throw new TypeError(\n            \"Invalid lazy handler result. It should be a function:\",\n            handler\n          );\n        }\n        _resolved = toEventHandler(r.default || r);\n        return _resolved;\n      });\n    }\n    return _promise;\n  };\n  return eventHandler((event) => {\n    if (_resolved) {\n      return _resolved(event);\n    }\n    return resolveHandler().then((handler) => handler(event));\n  });\n}\nconst lazyEventHandler = defineLazyEventHandler;\n\nfunction createApp(options = {}) {\n  const stack = [];\n  const handler = createAppEventHandler(stack, options);\n  const app = {\n    // @ts-ignore\n    use: (arg1, arg2, arg3) => use(app, arg1, arg2, arg3),\n    handler,\n    stack,\n    options\n  };\n  return app;\n}\nfunction use(app, arg1, arg2, arg3) {\n  if (Array.isArray(arg1)) {\n    for (const i of arg1) {\n      use(app, i, arg2, arg3);\n    }\n  } else if (Array.isArray(arg2)) {\n    for (const i of arg2) {\n      use(app, arg1, i, arg3);\n    }\n  } else if (typeof arg1 === \"string\") {\n    app.stack.push(\n      normalizeLayer({ ...arg3, route: arg1, handler: arg2 })\n    );\n  } else if (typeof arg1 === \"function\") {\n    app.stack.push(\n      normalizeLayer({ ...arg2, route: \"/\", handler: arg1 })\n    );\n  } else {\n    app.stack.push(normalizeLayer({ ...arg1 }));\n  }\n  return app;\n}\nfunction createAppEventHandler(stack, options) {\n  const spacing = options.debug ? 2 : void 0;\n  return eventHandler(async (event) => {\n    event.node.req.originalUrl = event.node.req.originalUrl || event.node.req.url || \"/\";\n    const reqUrl = event.node.req.url || \"/\";\n    for (const layer of stack) {\n      if (layer.route.length > 1) {\n        if (!reqUrl.startsWith(layer.route)) {\n          continue;\n        }\n        event.node.req.url = reqUrl.slice(layer.route.length) || \"/\";\n      } else {\n        event.node.req.url = reqUrl;\n      }\n      if (layer.match && !layer.match(event.node.req.url, event)) {\n        continue;\n      }\n      const val = await layer.handler(event);\n      if (event.node.res.writableEnded) {\n        return;\n      }\n      const type = typeof val;\n      if (type === \"string\") {\n        return send(event, val, MIMES.html);\n      } else if (isStream(val)) {\n        return sendStream(event, val);\n      } else if (val === null) {\n        event.node.res.statusCode = 204;\n        return send(event);\n      } else if (type === \"object\" || type === \"boolean\" || type === \"number\") {\n        if (val.buffer) {\n          return send(event, val);\n        } else if (val instanceof Error) {\n          throw createError(val);\n        } else {\n          return send(\n            event,\n            JSON.stringify(val, void 0, spacing),\n            MIMES.json\n          );\n        }\n      }\n    }\n    if (!event.node.res.writableEnded) {\n      throw createError({\n        statusCode: 404,\n        statusMessage: `Cannot find any route matching ${event.node.req.url || \"/\"}.`\n      });\n    }\n  });\n}\nfunction normalizeLayer(input) {\n  let handler = input.handler;\n  if (handler.handler) {\n    handler = handler.handler;\n  }\n  if (input.lazy) {\n    handler = lazyEventHandler(handler);\n  } else if (!isEventHandler(handler)) {\n    handler = toEventHandler(handler, void 0, input.route);\n  }\n  return {\n    route: withoutTrailingSlash(input.route),\n    match: input.match,\n    handler\n  };\n}\n\nconst defineNodeListener = (handler) => handler;\nconst defineNodeMiddleware = (middleware) => middleware;\nfunction fromNodeMiddleware(handler) {\n  if (isEventHandler(handler)) {\n    return handler;\n  }\n  if (typeof handler !== \"function\") {\n    throw new TypeError(\n      \"Invalid handler. It should be a function:\",\n      handler\n    );\n  }\n  return eventHandler((event) => {\n    return callNodeListener(\n      handler,\n      event.node.req,\n      event.node.res\n    );\n  });\n}\nfunction toNodeListener(app) {\n  const toNodeHandle = async function(req, res) {\n    const event = createEvent(req, res);\n    try {\n      await app.handler(event);\n    } catch (_error) {\n      const error = createError(_error);\n      if (!isError(_error)) {\n        error.unhandled = true;\n      }\n      if (app.options.onError) {\n        await app.options.onError(error, event);\n      } else {\n        if (error.unhandled || error.fatal) {\n          console.error(\"[h3]\", error.fatal ? \"[fatal]\" : \"[unhandled]\", error);\n        }\n        await sendError(event, error, !!app.options.debug);\n      }\n    }\n  };\n  return toNodeHandle;\n}\nfunction promisifyNodeListener(handler) {\n  return function(req, res) {\n    return callNodeListener(handler, req, res);\n  };\n}\nfunction callNodeListener(handler, req, res) {\n  const isMiddleware = handler.length > 2;\n  return new Promise((resolve, reject) => {\n    const next = (err) => {\n      if (isMiddleware) {\n        res.off(\"close\", next);\n        res.off(\"error\", next);\n      }\n      return err ? reject(createError(err)) : resolve(void 0);\n    };\n    try {\n      const returned = handler(req, res, next);\n      if (isMiddleware && returned === void 0) {\n        res.once(\"close\", next);\n        res.once(\"error\", next);\n      } else {\n        resolve(returned);\n      }\n    } catch (error) {\n      next(error);\n    }\n  });\n}\n\nconst RouterMethods = [\n  \"connect\",\n  \"delete\",\n  \"get\",\n  \"head\",\n  \"options\",\n  \"post\",\n  \"put\",\n  \"trace\",\n  \"patch\"\n];\nfunction createRouter(opts = {}) {\n  const _router = createRouter$1({});\n  const routes = {};\n  const router = {};\n  const addRoute = (path, handler, method) => {\n    let route = routes[path];\n    if (!route) {\n      routes[path] = route = { handlers: {} };\n      _router.insert(path, route);\n    }\n    if (Array.isArray(method)) {\n      for (const m of method) {\n        addRoute(path, handler, m);\n      }\n    } else {\n      route.handlers[method] = toEventHandler(handler, void 0, path);\n    }\n    return router;\n  };\n  router.use = router.add = (path, handler, method) => addRoute(path, handler, method || \"all\");\n  for (const method of RouterMethods) {\n    router[method] = (path, handle) => router.add(path, handle, method);\n  }\n  router.handler = eventHandler((event) => {\n    let path = event.node.req.url || \"/\";\n    const qIndex = path.indexOf(\"?\");\n    if (qIndex !== -1) {\n      path = path.slice(0, Math.max(0, qIndex));\n    }\n    const matched = _router.lookup(path);\n    if (!matched || !matched.handlers) {\n      if (opts.preemptive || opts.preemtive) {\n        throw createError({\n          statusCode: 404,\n          name: \"Not Found\",\n          statusMessage: `Cannot find any route matching ${event.node.req.url || \"/\"}.`\n        });\n      } else {\n        return;\n      }\n    }\n    const method = (event.node.req.method || \"get\").toLowerCase();\n    const handler = matched.handlers[method] || matched.handlers.all;\n    if (!handler) {\n      throw createError({\n        statusCode: 405,\n        name: \"Method Not Allowed\",\n        statusMessage: `Method ${method} is not allowed on this route.`\n      });\n    }\n    const params = matched.params || {};\n    event.context.params = params;\n    return handler(event);\n  });\n  return router;\n}\n\nexport { H3Error, H3Event, H3Headers, H3Response, MIMES, appendHeader, appendHeaders, appendResponseHeader, appendResponseHeaders, assertMethod, callNodeListener, createApp, createAppEventHandler, createError, createEvent, createRouter, defaultContentType, defineEventHandler, defineLazyEventHandler, defineNodeListener, defineNodeMiddleware, deleteCookie, dynamicEventHandler, eventHandler, fromNodeMiddleware, getCookie, getHeader, getHeaders, getMethod, getQuery, getRequestHeader, getRequestHeaders, getResponseHeader, getResponseHeaders, getResponseStatus, getResponseStatusText, getRouterParam, getRouterParams, handleCacheHeaders, isError, isEvent, isEventHandler, isMethod, isStream, lazyEventHandler, parseCookies, promisifyNodeListener, proxyRequest, readBody, readMultipartFormData, readRawBody, send, sendError, sendNoContent, sendProxy, sendRedirect, sendStream, setCookie, setHeader, setHeaders, setResponseHeader, setResponseHeaders, setResponseStatus, toEventHandler, toNodeListener, use, useBase, writeEarlyHints };\n", "import { createError as _createError } from \"h3\";\nimport { toRef } from \"vue\";\nimport { useNuxtApp } from \"../nuxt.mjs\";\nexport const useError = () => toRef(useNuxtApp().payload, \"error\");\nexport const showError = (_err) => {\n  const err = createError(_err);\n  try {\n    const nuxtApp = useNuxtApp();\n    nuxtApp.callHook(\"app:error\", err);\n    const error = useError();\n    error.value = error.value || err;\n  } catch {\n    throw err;\n  }\n  return err;\n};\nexport const clearError = async (options = {}) => {\n  const nuxtApp = useNuxtApp();\n  const error = useError();\n  nuxtApp.callHook(\"app:error:cleared\", options);\n  if (options.redirect) {\n    await nuxtApp.$router.replace(options.redirect);\n  }\n  error.value = null;\n};\nexport const isNuxtError = (err) => !!(err && typeof err === \"object\" && \"__nuxt_error\" in err);\nexport const createError = (err) => {\n  const _err = _createError(err);\n  _err.__nuxt_error = true;\n  return _err;\n};\n", "import { onBeforeMount, onServerPrefetch, onUnmounted, ref, getCurrentInstance, watch, unref, toRef } from \"vue\";\nimport { useNuxtApp } from \"../nuxt.mjs\";\nimport { createError } from \"./error.mjs\";\nconst getDefault = () => null;\nexport function useAsyncData(...args) {\n  const autoKey = typeof args[args.length - 1] === \"string\" ? args.pop() : void 0;\n  if (typeof args[0] !== \"string\") {\n    args.unshift(autoKey);\n  }\n  let [key, handler, options = {}] = args;\n  if (typeof key !== \"string\") {\n    throw new TypeError(\"[nuxt] [asyncData] key must be a string.\");\n  }\n  if (typeof handler !== \"function\") {\n    throw new TypeError(\"[nuxt] [asyncData] handler must be a function.\");\n  }\n  options.server = options.server ?? true;\n  options.default = options.default ?? getDefault;\n  options.lazy = options.lazy ?? false;\n  options.immediate = options.immediate ?? true;\n  const nuxt = useNuxtApp();\n  const getCachedData = () => nuxt.isHydrating ? nuxt.payload.data[key] : nuxt.static.data[key];\n  const hasCachedData = () => getCachedData() !== void 0;\n  if (!nuxt._asyncData[key]) {\n    nuxt._asyncData[key] = {\n      data: ref(getCachedData() ?? options.default?.() ?? null),\n      pending: ref(!hasCachedData()),\n      error: ref(nuxt.payload._errors[key] ? createError(nuxt.payload._errors[key]) : null)\n    };\n  }\n  const asyncData = { ...nuxt._asyncData[key] };\n  asyncData.refresh = asyncData.execute = (opts = {}) => {\n    if (nuxt._asyncDataPromises[key]) {\n      if (opts.dedupe === false) {\n        return nuxt._asyncDataPromises[key];\n      }\n      nuxt._asyncDataPromises[key].cancelled = true;\n    }\n    if (opts._initial && hasCachedData()) {\n      return getCachedData();\n    }\n    asyncData.pending.value = true;\n    const promise = new Promise(\n      (resolve, reject) => {\n        try {\n          resolve(handler(nuxt));\n        } catch (err) {\n          reject(err);\n        }\n      }\n    ).then((result) => {\n      if (promise.cancelled) {\n        return nuxt._asyncDataPromises[key];\n      }\n      if (options.transform) {\n        result = options.transform(result);\n      }\n      if (options.pick) {\n        result = pick(result, options.pick);\n      }\n      asyncData.data.value = result;\n      asyncData.error.value = null;\n    }).catch((error) => {\n      if (promise.cancelled) {\n        return nuxt._asyncDataPromises[key];\n      }\n      asyncData.error.value = error;\n      asyncData.data.value = unref(options.default?.() ?? null);\n    }).finally(() => {\n      if (promise.cancelled) {\n        return;\n      }\n      asyncData.pending.value = false;\n      nuxt.payload.data[key] = asyncData.data.value;\n      if (asyncData.error.value) {\n        nuxt.payload._errors[key] = createError(asyncData.error.value);\n      }\n      delete nuxt._asyncDataPromises[key];\n    });\n    nuxt._asyncDataPromises[key] = promise;\n    return nuxt._asyncDataPromises[key];\n  };\n  const initialFetch = () => asyncData.refresh({ _initial: true });\n  const fetchOnServer = options.server !== false && nuxt.payload.serverRendered;\n  if (process.server && fetchOnServer && options.immediate) {\n    const promise = initialFetch();\n    if (getCurrentInstance()) {\n      onServerPrefetch(() => promise);\n    } else {\n      nuxt.hook(\"app:created\", () => promise);\n    }\n  }\n  if (process.client) {\n    const instance = getCurrentInstance();\n    if (instance && !instance._nuxtOnBeforeMountCbs) {\n      instance._nuxtOnBeforeMountCbs = [];\n      const cbs = instance._nuxtOnBeforeMountCbs;\n      if (instance) {\n        onBeforeMount(() => {\n          cbs.forEach((cb) => {\n            cb();\n          });\n          cbs.splice(0, cbs.length);\n        });\n        onUnmounted(() => cbs.splice(0, cbs.length));\n      }\n    }\n    if (fetchOnServer && nuxt.isHydrating && hasCachedData()) {\n      asyncData.pending.value = false;\n    } else if (instance && (nuxt.payload.serverRendered && nuxt.isHydrating || options.lazy) && options.immediate) {\n      instance._nuxtOnBeforeMountCbs.push(initialFetch);\n    } else if (options.immediate) {\n      initialFetch();\n    }\n    if (options.watch) {\n      watch(options.watch, () => asyncData.refresh());\n    }\n    const off = nuxt.hook(\"app:data:refresh\", (keys) => {\n      if (!keys || keys.includes(key)) {\n        return asyncData.refresh();\n      }\n    });\n    if (instance) {\n      onUnmounted(off);\n    }\n  }\n  const asyncDataPromise = Promise.resolve(nuxt._asyncDataPromises[key]).then(() => asyncData);\n  Object.assign(asyncDataPromise, asyncData);\n  return asyncDataPromise;\n}\nexport function useLazyAsyncData(...args) {\n  const autoKey = typeof args[args.length - 1] === \"string\" ? args.pop() : void 0;\n  if (typeof args[0] !== \"string\") {\n    args.unshift(autoKey);\n  }\n  const [key, handler, options] = args;\n  return useAsyncData(key, handler, { ...options, lazy: true }, null);\n}\nexport function useNuxtData(key) {\n  const nuxt = useNuxtApp();\n  if (!(key in nuxt.payload.data)) {\n    nuxt.payload.data[key] = null;\n  }\n  return {\n    data: toRef(nuxt.payload.data, key)\n  };\n}\nexport async function refreshNuxtData(keys) {\n  if (process.server) {\n    return Promise.resolve();\n  }\n  const _keys = keys ? Array.isArray(keys) ? keys : [keys] : void 0;\n  await useNuxtApp().hooks.callHookParallel(\"app:data:refresh\", _keys);\n}\nexport function clearNuxtData(keys) {\n  const nuxtApp = useNuxtApp();\n  const _allKeys = Object.keys(nuxtApp.payload.data);\n  const _keys = !keys ? _allKeys : typeof keys === \"function\" ? _allKeys.filter(keys) : Array.isArray(keys) ? keys : [keys];\n  for (const key of _keys) {\n    if (key in nuxtApp.payload.data) {\n      nuxtApp.payload.data[key] = void 0;\n    }\n    if (key in nuxtApp.payload._errors) {\n      nuxtApp.payload._errors[key] = void 0;\n    }\n    if (nuxtApp._asyncData[key]) {\n      nuxtApp._asyncData[key].data.value = void 0;\n      nuxtApp._asyncData[key].error.value = void 0;\n      nuxtApp._asyncData[key].pending.value = false;\n    }\n    if (key in nuxtApp._asyncDataPromises) {\n      nuxtApp._asyncDataPromises[key] = void 0;\n    }\n  }\n}\nfunction pick(obj, keys) {\n  const newObj = {};\n  for (const key of keys) {\n    newObj[key] = obj[key];\n  }\n  return newObj;\n}\n", "import { isRef, toRef } from \"vue\";\nimport { useNuxtApp } from \"../nuxt.mjs\";\nexport function useState(...args) {\n  const autoKey = typeof args[args.length - 1] === \"string\" ? args.pop() : void 0;\n  if (typeof args[0] !== \"string\") {\n    args.unshift(autoKey);\n  }\n  const [_key, init] = args;\n  if (!_key || typeof _key !== \"string\") {\n    throw new TypeError(\"[nuxt] [useState] key must be a string: \" + _key);\n  }\n  if (init !== void 0 && typeof init !== \"function\") {\n    throw new Error(\"[nuxt] [useState] init must be a function: \" + init);\n  }\n  const key = \"$s\" + _key;\n  const nuxt = useNuxtApp();\n  const state = toRef(nuxt.payload.state, key);\n  if (state.value === void 0 && init) {\n    const initialValue = init();\n    if (isRef(initialValue)) {\n      nuxt.payload.state[key] = initialValue;\n      return initialValue;\n    }\n    state.value = initialValue;\n  }\n  return state;\n}\n", "import { useNuxtApp } from \"../nuxt.mjs\";\nexport function useRequestHeaders(include) {\n  if (process.client) {\n    return {};\n  }\n  const headers = useNuxtApp().ssrContext?.event.node.req.headers ?? {};\n  if (!include) {\n    return headers;\n  }\n  return Object.fromEntries(include.map((key) => key.toLowerCase()).filter((key) => headers[key]).map((key) => [key, headers[key]]));\n}\nexport function useRequestEvent(nuxtApp = useNuxtApp()) {\n  return nuxtApp.ssrContext?.event;\n}\nexport function setResponseStatus(code, message) {\n  const event = process.server && useRequestEvent();\n  if (event) {\n    event.node.res.statusCode = code;\n    if (message) {\n      event.node.res.statusMessage = message;\n    }\n  }\n}\n", "import { getCurrentInstance, inject, onUnmounted } from \"vue\";\nimport { sendRedirect } from \"h3\";\nimport { hasProtocol, joinURL, parseURL } from \"ufo\";\nimport { useNuxtApp, useRuntimeConfig } from \"../nuxt.mjs\";\nimport { createError } from \"./error.mjs\";\nimport { useState } from \"./state.mjs\";\nimport { setResponseStatus } from \"./ssr.mjs\";\nexport const useRouter = () => {\n  return useNuxtApp()?.$router;\n};\nexport const useRoute = () => {\n  if (getCurrentInstance()) {\n    return inject(\"_route\", useNuxtApp()._route);\n  }\n  return useNuxtApp()._route;\n};\nexport const onBeforeRouteLeave = (guard) => {\n  const unsubscribe = useRouter().beforeEach((to, from, next) => {\n    if (to === from) {\n      return;\n    }\n    return guard(to, from, next);\n  });\n  onUnmounted(unsubscribe);\n};\nexport const onBeforeRouteUpdate = (guard) => {\n  const unsubscribe = useRouter().beforeEach(guard);\n  onUnmounted(unsubscribe);\n};\nexport const defineNuxtRouteMiddleware = (middleware) => middleware;\nexport const addRouteMiddleware = (name, middleware, options = {}) => {\n  const nuxtApp = useNuxtApp();\n  if (options.global || typeof name === \"function\") {\n    nuxtApp._middleware.global.push(typeof name === \"function\" ? name : middleware);\n  } else {\n    nuxtApp._middleware.named[name] = middleware;\n  }\n};\nconst isProcessingMiddleware = () => {\n  try {\n    if (useNuxtApp()._processingMiddleware) {\n      return true;\n    }\n  } catch {\n    return true;\n  }\n  return false;\n};\nexport const navigateTo = (to, options) => {\n  if (!to) {\n    to = \"/\";\n  }\n  const toPath = typeof to === \"string\" ? to : to.path || \"/\";\n  const isExternal = hasProtocol(toPath, true);\n  if (isExternal && !options?.external) {\n    throw new Error(\"Navigating to external URL is not allowed by default. Use `nagivateTo (url, { external: true })`.\");\n  }\n  if (isExternal && parseURL(toPath).protocol === \"script:\") {\n    throw new Error(\"Cannot navigate to an URL with script protocol.\");\n  }\n  if (process.client && !isExternal && isProcessingMiddleware()) {\n    return to;\n  }\n  const router = useRouter();\n  if (process.server) {\n    const nuxtApp = useNuxtApp();\n    if (nuxtApp.ssrContext && nuxtApp.ssrContext.event) {\n      if (isProcessingMiddleware() && !isExternal) {\n        setResponseStatus(options?.redirectCode || 302);\n        return to;\n      }\n      const redirectLocation = isExternal ? toPath : joinURL(useRuntimeConfig().app.baseURL, router.resolve(to).fullPath || \"/\");\n      return nuxtApp.callHook(\"app:redirected\").then(() => sendRedirect(nuxtApp.ssrContext.event, redirectLocation, options?.redirectCode || 302));\n    }\n  }\n  if (isExternal) {\n    if (options?.replace) {\n      location.replace(toPath);\n    } else {\n      location.href = toPath;\n    }\n    return Promise.resolve();\n  }\n  return options?.replace ? router.replace(to) : router.push(to);\n};\nexport const abortNavigation = (err) => {\n  if (process.dev && !isProcessingMiddleware()) {\n    throw new Error(\"abortNavigation() is only usable inside a route middleware handler.\");\n  }\n  if (err) {\n    throw createError(err);\n  }\n  return false;\n};\nexport const setPageLayout = (layout) => {\n  if (process.server) {\n    if (process.dev && getCurrentInstance() && useState(\"_layout\").value !== layout) {\n      console.warn(\"[warn] [nuxt] `setPageLayout` should not be called to change the layout on the server within a component as this will cause hydration errors.\");\n    }\n    useState(\"_layout\").value = layout;\n  }\n  const nuxtApp = useNuxtApp();\n  if (process.dev && nuxtApp.isHydrating && useState(\"_layout\").value !== layout) {\n    console.warn(\"[warn] [nuxt] `setPageLayout` should not be called to change the layout during hydration as this will cause hydration errors.\");\n  }\n  const inMiddleware = isProcessingMiddleware();\n  if (inMiddleware || process.server || nuxtApp.isHydrating) {\n    const unsubscribe = useRouter().beforeResolve((to) => {\n      to.meta.layout = layout;\n      unsubscribe();\n    });\n  }\n  if (!inMiddleware) {\n    useRoute().meta.layout = layout;\n  }\n};\n", "import { createHooks } from 'hookable';\nimport { unref, isRef, version, getCurrentInstance, inject, nextTick, ref, watchEffect, watch, onBeforeUnmount } from 'vue';\n\nconst TagsWithInnerContent = [\"script\", \"style\", \"noscript\"];\nconst HasElementTags$1 = [\n  \"base\",\n  \"meta\",\n  \"link\",\n  \"style\",\n  \"script\",\n  \"noscript\"\n];\n\nconst UniqueTags$1 = [\"base\", \"title\", \"titleTemplate\", \"bodyAttrs\", \"htmlAttrs\"];\nfunction tagDedupeKey$1(tag, fn) {\n  const { props, tag: tagName } = tag;\n  if (UniqueTags$1.includes(tagName))\n    return tagName;\n  if (tagName === \"link\" && props.rel === \"canonical\")\n    return \"canonical\";\n  if (props.charset)\n    return \"charset\";\n  const name = [\"id\"];\n  if (tagName === \"meta\")\n    name.push(...[\"name\", \"property\", \"http-equiv\"]);\n  for (const n of name) {\n    if (typeof props[n] !== \"undefined\") {\n      const val = String(props[n]);\n      if (fn && !fn(val))\n        return false;\n      return `${tagName}:${n}:${val}`;\n    }\n  }\n  return false;\n}\n\nconst setAttrs = (ctx, markSideEffect) => {\n  const { tag, $el } = ctx;\n  if (!$el)\n    return;\n  Object.entries(tag.props).forEach(([k, value]) => {\n    value = String(value);\n    const attrSdeKey = `attr:${k}`;\n    if (k === \"class\") {\n      if (!value)\n        return;\n      for (const c of value.split(\" \")) {\n        const classSdeKey = `${attrSdeKey}:${c}`;\n        if (markSideEffect)\n          markSideEffect(ctx, classSdeKey, () => $el.classList.remove(c));\n        if (!$el.classList.contains(c))\n          $el.classList.add(c);\n      }\n      return;\n    }\n    if (markSideEffect && !k.startsWith(\"data-h-\"))\n      markSideEffect(ctx, attrSdeKey, () => $el.removeAttribute(k));\n    if ($el.getAttribute(k) !== value)\n      $el.setAttribute(k, value);\n  });\n  if (TagsWithInnerContent.includes(tag.tag) && $el.innerHTML !== (tag.children || \"\"))\n    $el.innerHTML = tag.children || \"\";\n};\n\nfunction hashCode(s) {\n  let h = 9;\n  for (let i = 0; i < s.length; )\n    h = Math.imul(h ^ s.charCodeAt(i++), 9 ** 9);\n  return ((h ^ h >>> 9) + 65536).toString(16).substring(1, 8).toLowerCase();\n}\n\nasync function renderDOMHead(head, options = {}) {\n  const ctx = { shouldRender: true };\n  await head.hooks.callHook(\"dom:beforeRender\", ctx);\n  if (!ctx.shouldRender)\n    return;\n  const dom = options.document || window.document;\n  const staleSideEffects = head._popSideEffectQueue();\n  head.headEntries().map((entry) => entry._sde).forEach((sde) => {\n    Object.entries(sde).forEach(([key, fn]) => {\n      staleSideEffects[key] = fn;\n    });\n  });\n  const preRenderTag = async (tag) => {\n    const entry = head.headEntries().find((e) => e._i === tag._e);\n    const renderCtx = {\n      renderId: tag._d || hashCode(JSON.stringify({ ...tag, _e: void 0, _p: void 0 })),\n      $el: null,\n      shouldRender: true,\n      tag,\n      entry,\n      staleSideEffects\n    };\n    await head.hooks.callHook(\"dom:beforeRenderTag\", renderCtx);\n    return renderCtx;\n  };\n  const renders = [];\n  const pendingRenders = {\n    body: [],\n    head: []\n  };\n  const markSideEffect = (ctx2, key, fn) => {\n    key = `${ctx2.renderId}:${key}`;\n    if (ctx2.entry)\n      ctx2.entry._sde[key] = fn;\n    delete staleSideEffects[key];\n  };\n  const markEl = (ctx2) => {\n    head._elMap[ctx2.renderId] = ctx2.$el;\n    renders.push(ctx2);\n    markSideEffect(ctx2, \"el\", () => {\n      ctx2.$el?.remove();\n      delete head._elMap[ctx2.renderId];\n    });\n  };\n  for (const t of await head.resolveTags()) {\n    const ctx2 = await preRenderTag(t);\n    if (!ctx2.shouldRender)\n      continue;\n    const { tag } = ctx2;\n    if (tag.tag === \"title\") {\n      dom.title = tag.children || \"\";\n      renders.push(ctx2);\n      continue;\n    }\n    if (tag.tag === \"htmlAttrs\" || tag.tag === \"bodyAttrs\") {\n      ctx2.$el = dom[tag.tag === \"htmlAttrs\" ? \"documentElement\" : \"body\"];\n      setAttrs(ctx2, markSideEffect);\n      renders.push(ctx2);\n      continue;\n    }\n    ctx2.$el = head._elMap[ctx2.renderId];\n    if (!ctx2.$el && tag._hash) {\n      ctx2.$el = dom.querySelector(`${tag.tagPosition?.startsWith(\"body\") ? \"body\" : \"head\"} > ${tag.tag}[data-h-${tag._hash}]`);\n    }\n    if (ctx2.$el) {\n      if (ctx2.tag._d)\n        setAttrs(ctx2);\n      markEl(ctx2);\n      continue;\n    }\n    ctx2.$el = dom.createElement(tag.tag);\n    setAttrs(ctx2);\n    pendingRenders[tag.tagPosition?.startsWith(\"body\") ? \"body\" : \"head\"].push(ctx2);\n  }\n  Object.entries(pendingRenders).forEach(([pos, queue]) => {\n    if (!queue.length)\n      return;\n    const children = dom?.[pos]?.children;\n    if (!children)\n      return;\n    for (const $el of [...children].reverse()) {\n      const elTag = $el.tagName.toLowerCase();\n      if (!HasElementTags$1.includes(elTag))\n        continue;\n      const dedupeKey = tagDedupeKey$1({\n        tag: elTag,\n        // convert attributes to object\n        props: $el.getAttributeNames().reduce((props, name) => ({ ...props, [name]: $el.getAttribute(name) }), {})\n      });\n      const matchIdx = queue.findIndex((ctx2) => ctx2 && (ctx2.tag._d === dedupeKey || $el.isEqualNode?.(ctx2.$el)));\n      if (matchIdx !== -1) {\n        const ctx2 = queue[matchIdx];\n        ctx2.$el = $el;\n        setAttrs(ctx2);\n        markEl(ctx2);\n        delete queue[matchIdx];\n      }\n    }\n    queue.forEach((ctx2) => {\n      if (!ctx2.$el)\n        return;\n      switch (ctx2.tag.tagPosition) {\n        case \"bodyClose\":\n          dom.body.appendChild(ctx2.$el);\n          break;\n        case \"bodyOpen\":\n          dom.body.insertBefore(ctx2.$el, dom.body.firstChild);\n          break;\n        case \"head\":\n        default:\n          dom.head.appendChild(ctx2.$el);\n          break;\n      }\n      markEl(ctx2);\n    });\n  });\n  for (const ctx2 of renders)\n    await head.hooks.callHook(\"dom:renderTag\", ctx2);\n  Object.values(staleSideEffects).forEach((fn) => fn());\n}\nlet domUpdatePromise = null;\nasync function debouncedRenderDOMHead(head, options = {}) {\n  function doDomUpdate() {\n    domUpdatePromise = null;\n    return renderDOMHead(head, options);\n  }\n  const delayFn = options.delayFn || ((fn) => setTimeout(fn, 10));\n  return domUpdatePromise = domUpdatePromise || new Promise((resolve) => delayFn(() => resolve(doDomUpdate())));\n}\n\nconst index = {\n  __proto__: null,\n  debouncedRenderDOMHead: debouncedRenderDOMHead,\n  get domUpdatePromise () { return domUpdatePromise; },\n  hashCode: hashCode,\n  renderDOMHead: renderDOMHead\n};\n\nconst ValidHeadTags = [\n  \"title\",\n  \"titleTemplate\",\n  \"base\",\n  \"htmlAttrs\",\n  \"bodyAttrs\",\n  \"meta\",\n  \"link\",\n  \"style\",\n  \"script\",\n  \"noscript\"\n];\nconst TagConfigKeys = [\"tagPosition\", \"tagPriority\", \"tagDuplicateStrategy\"];\n\nasync function normaliseTag(tagName, input) {\n  const tag = { tag: tagName, props: {} };\n  if (tagName === \"title\" || tagName === \"titleTemplate\") {\n    tag.children = input instanceof Promise ? await input : input;\n    return tag;\n  }\n  tag.props = await normaliseProps({ ...input });\n  [\"children\", \"innerHtml\", \"innerHTML\"].forEach((key) => {\n    if (typeof tag.props[key] !== \"undefined\") {\n      tag.children = tag.props[key];\n      if (typeof tag.children === \"object\")\n        tag.children = JSON.stringify(tag.children);\n      delete tag.props[key];\n    }\n  });\n  Object.keys(tag.props).filter((k) => TagConfigKeys.includes(k)).forEach((k) => {\n    tag[k] = tag.props[k];\n    delete tag.props[k];\n  });\n  if (typeof tag.props.class === \"object\" && !Array.isArray(tag.props.class)) {\n    tag.props.class = Object.keys(tag.props.class).filter((k) => tag.props.class[k]);\n  }\n  if (Array.isArray(tag.props.class))\n    tag.props.class = tag.props.class.join(\" \");\n  if (tag.props.content && Array.isArray(tag.props.content)) {\n    return tag.props.content.map((v, i) => {\n      const newTag = { ...tag, props: { ...tag.props } };\n      newTag.props.content = v;\n      newTag.key = `${tag.props.name || tag.props.property}:${i}`;\n      return newTag;\n    });\n  }\n  return tag;\n}\nasync function normaliseProps(props) {\n  for (const k of Object.keys(props)) {\n    if (props[k] instanceof Promise) {\n      props[k] = await props[k];\n    }\n    if (String(props[k]) === \"true\") {\n      props[k] = \"\";\n    } else if (String(props[k]) === \"false\") {\n      delete props[k];\n    }\n  }\n  return props;\n}\n\nconst tagWeight = (tag) => {\n  if (typeof tag.tagPriority === \"number\")\n    return tag.tagPriority;\n  switch (tag.tagPriority) {\n    case \"critical\":\n      return 2;\n    case \"high\":\n      return 9;\n    case \"low\":\n      return 12;\n  }\n  switch (tag.tag) {\n    case \"base\":\n      return -1;\n    case \"title\":\n      return 1;\n    case \"meta\":\n      if (tag.props.charset)\n        return -2;\n      if (tag.props[\"http-equiv\"] === \"content-security-policy\")\n        return 0;\n      return 10;\n    default:\n      return 10;\n  }\n};\nconst sortTags = (aTag, bTag) => {\n  return tagWeight(aTag) - tagWeight(bTag);\n};\n\nconst UniqueTags = [\"base\", \"title\", \"titleTemplate\", \"bodyAttrs\", \"htmlAttrs\"];\nfunction tagDedupeKey(tag, fn) {\n  const { props, tag: tagName } = tag;\n  if (UniqueTags.includes(tagName))\n    return tagName;\n  if (tagName === \"link\" && props.rel === \"canonical\")\n    return \"canonical\";\n  if (props.charset)\n    return \"charset\";\n  const name = [\"id\"];\n  if (tagName === \"meta\")\n    name.push(...[\"name\", \"property\", \"http-equiv\"]);\n  for (const n of name) {\n    if (typeof props[n] !== \"undefined\") {\n      const val = String(props[n]);\n      if (fn && !fn(val))\n        return false;\n      return `${tagName}:${n}:${val}`;\n    }\n  }\n  return false;\n}\n\nconst renderTitleTemplate = (template, title) => {\n  if (template == null)\n    return title || null;\n  if (typeof template === \"function\")\n    return template(title);\n  return template.replace(\"%s\", title ?? \"\");\n};\nfunction resolveTitleTemplateFromTags(tags) {\n  let titleTemplateIdx = tags.findIndex((i) => i.tag === \"titleTemplate\");\n  const titleIdx = tags.findIndex((i) => i.tag === \"title\");\n  if (titleIdx !== -1 && titleTemplateIdx !== -1) {\n    const newTitle = renderTitleTemplate(\n      tags[titleTemplateIdx].children,\n      tags[titleIdx].children\n    );\n    if (newTitle !== null) {\n      tags[titleIdx].children = newTitle || tags[titleIdx].children;\n    } else {\n      delete tags[titleIdx];\n    }\n  } else if (titleTemplateIdx !== -1) {\n    const newTitle = renderTitleTemplate(\n      tags[titleTemplateIdx].children\n    );\n    if (newTitle !== null) {\n      tags[titleTemplateIdx].children = newTitle;\n      tags[titleTemplateIdx].tag = \"title\";\n      titleTemplateIdx = -1;\n    }\n  }\n  if (titleTemplateIdx !== -1) {\n    delete tags[titleTemplateIdx];\n  }\n  return tags.filter(Boolean);\n}\n\nconst DedupesTagsPlugin = (options) => {\n  options = options || {};\n  const dedupeKeys = options.dedupeKeys || [\"hid\", \"vmid\", \"key\"];\n  return defineHeadPlugin({\n    hooks: {\n      \"tag:normalise\": function({ tag }) {\n        dedupeKeys.forEach((key) => {\n          if (tag.props[key]) {\n            tag.key = tag.props[key];\n            delete tag.props[key];\n          }\n        });\n        const dedupe = tag.key ? `${tag.tag}:${tag.key}` : tagDedupeKey(tag);\n        if (dedupe)\n          tag._d = dedupe;\n      },\n      \"tags:resolve\": function(ctx) {\n        const deduping = {};\n        ctx.tags.forEach((tag) => {\n          let dedupeKey = tag._d || tag._p;\n          const dupedTag = deduping[dedupeKey];\n          if (dupedTag) {\n            let strategy = tag?.tagDuplicateStrategy;\n            if (!strategy && (tag.tag === \"htmlAttrs\" || tag.tag === \"bodyAttrs\"))\n              strategy = \"merge\";\n            if (strategy === \"merge\") {\n              const oldProps = dupedTag.props;\n              [\"class\", \"style\"].forEach((key) => {\n                if (tag.props[key] && oldProps[key]) {\n                  if (key === \"style\" && !oldProps[key].endsWith(\";\"))\n                    oldProps[key] += \";\";\n                  tag.props[key] = `${oldProps[key]} ${tag.props[key]}`;\n                }\n              });\n              deduping[dedupeKey].props = {\n                ...oldProps,\n                ...tag.props\n              };\n              return;\n            } else if (tag._e === dupedTag._e) {\n              dedupeKey = tag._d = `${dedupeKey}:${tag._p}`;\n            }\n            const propCount = Object.keys(tag.props).length;\n            if ((propCount === 0 || propCount === 1 && typeof tag.props[\"data-h-key\"] !== \"undefined\") && !tag.children) {\n              delete deduping[dedupeKey];\n              return;\n            }\n          }\n          deduping[dedupeKey] = tag;\n        });\n        ctx.tags = Object.values(deduping);\n      }\n    }\n  });\n};\n\nconst SortTagsPlugin = () => {\n  return defineHeadPlugin({\n    hooks: {\n      \"tags:resolve\": (ctx) => {\n        const tagIndexForKey = (key) => ctx.tags.find((tag) => tag._d === key)?._p;\n        for (const tag of ctx.tags) {\n          if (!tag.tagPriority || typeof tag.tagPriority === \"number\")\n            continue;\n          const modifiers = [{ prefix: \"before:\", offset: -1 }, { prefix: \"after:\", offset: 1 }];\n          for (const { prefix, offset } of modifiers) {\n            if (tag.tagPriority.startsWith(prefix)) {\n              const key = tag.tagPriority.replace(prefix, \"\");\n              const index = tagIndexForKey(key);\n              if (typeof index !== \"undefined\")\n                tag._p = index + offset;\n            }\n          }\n        }\n        ctx.tags.sort((a, b) => a._p - b._p).sort(sortTags);\n      }\n    }\n  });\n};\n\nconst TitleTemplatePlugin = () => {\n  return defineHeadPlugin({\n    hooks: {\n      \"tags:resolve\": (ctx) => {\n        ctx.tags = resolveTitleTemplateFromTags(ctx.tags);\n      }\n    }\n  });\n};\n\nconst DeprecatedTagAttrPlugin = () => {\n  return defineHeadPlugin({\n    hooks: {\n      \"tag:normalise\": function({ tag }) {\n        if (typeof tag.props.body !== \"undefined\") {\n          tag.tagPosition = \"bodyClose\";\n          delete tag.props.body;\n        }\n      }\n    }\n  });\n};\n\nconst IsBrowser$1 = typeof window !== \"undefined\";\n\nconst ProvideTagHashPlugin = () => {\n  return defineHeadPlugin({\n    hooks: {\n      \"tag:normalise\": (ctx) => {\n        const { tag, entry } = ctx;\n        const isDynamic = typeof tag.props._dynamic !== \"undefined\";\n        if (!HasElementTags.includes(tag.tag) || !tag.key)\n          return;\n        tag._hash = hashCode(JSON.stringify({ tag: tag.tag, key: tag.key }));\n        if (IsBrowser$1 || getActiveHead()?.resolvedOptions?.document)\n          return;\n        if (entry._m === \"server\" || isDynamic) {\n          tag.props[`data-h-${tag._hash}`] = \"\";\n        }\n      },\n      \"tags:resolve\": (ctx) => {\n        ctx.tags = ctx.tags.map((t) => {\n          delete t.props._dynamic;\n          return t;\n        });\n      }\n    }\n  });\n};\n\nconst PatchDomOnEntryUpdatesPlugin = (options) => {\n  return defineHeadPlugin({\n    hooks: {\n      \"entries:updated\": function(head) {\n        if (typeof options?.document === \"undefined\" && typeof window === \"undefined\")\n          return;\n        let delayFn = options?.delayFn;\n        if (!delayFn && typeof requestAnimationFrame !== \"undefined\")\n          delayFn = requestAnimationFrame;\n        Promise.resolve().then(function () { return index; }).then(({ debouncedRenderDOMHead }) => {\n          debouncedRenderDOMHead(head, { document: options?.document || window.document, delayFn });\n        });\n      }\n    }\n  });\n};\n\nconst EventHandlersPlugin = () => {\n  const stripEventHandlers = (mode, tag) => {\n    const props = {};\n    const eventHandlers = {};\n    Object.entries(tag.props).forEach(([key, value]) => {\n      if (key.startsWith(\"on\") && typeof value === \"function\")\n        eventHandlers[key] = value;\n      else\n        props[key] = value;\n    });\n    let delayedSrc;\n    if (mode === \"dom\" && tag.tag === \"script\" && typeof props.src === \"string\" && typeof eventHandlers.onload !== \"undefined\") {\n      delayedSrc = props.src;\n      delete props.src;\n    }\n    return { props, eventHandlers, delayedSrc };\n  };\n  return defineHeadPlugin({\n    hooks: {\n      \"ssr:render\": function(ctx) {\n        ctx.tags = ctx.tags.map((tag) => {\n          tag.props = stripEventHandlers(\"ssr\", tag).props;\n          return tag;\n        });\n      },\n      \"dom:beforeRenderTag\": function(ctx) {\n        const { props, eventHandlers, delayedSrc } = stripEventHandlers(\"dom\", ctx.tag);\n        if (!Object.keys(eventHandlers).length)\n          return;\n        ctx.tag.props = props;\n        ctx.tag._eventHandlers = eventHandlers;\n        ctx.tag._delayedSrc = delayedSrc;\n      },\n      \"dom:renderTag\": function(ctx) {\n        const $el = ctx.$el;\n        if (!ctx.tag._eventHandlers || !$el)\n          return;\n        const $eventListenerTarget = ctx.tag.tag === \"bodyAttrs\" && typeof window !== \"undefined\" ? window : $el;\n        Object.entries(ctx.tag._eventHandlers).forEach(([k, value]) => {\n          const sdeKey = `${ctx.tag._d || ctx.tag._p}:${k}`;\n          const eventName = k.slice(2).toLowerCase();\n          const eventDedupeKey = `data-h-${eventName}`;\n          delete ctx.staleSideEffects[sdeKey];\n          if ($el.hasAttribute(eventDedupeKey))\n            return;\n          const handler = value;\n          $el.setAttribute(eventDedupeKey, \"\");\n          $eventListenerTarget.addEventListener(eventName, handler);\n          if (ctx.entry) {\n            ctx.entry._sde[sdeKey] = () => {\n              $eventListenerTarget.removeEventListener(eventName, handler);\n              $el.removeAttribute(eventDedupeKey);\n            };\n          }\n        });\n        if (ctx.tag._delayedSrc) {\n          $el.setAttribute(\"src\", ctx.tag._delayedSrc);\n        }\n      }\n    }\n  });\n};\n\nfunction asArray$1(value) {\n  return Array.isArray(value) ? value : [value];\n}\nconst HasElementTags = [\n  \"base\",\n  \"meta\",\n  \"link\",\n  \"style\",\n  \"script\",\n  \"noscript\"\n];\n\nlet activeHead;\nconst setActiveHead = (head) => activeHead = head;\nconst getActiveHead = () => activeHead;\n\nconst TagEntityBits = 10;\n\nasync function normaliseEntryTags(e) {\n  const tagPromises = [];\n  Object.entries(e.resolvedInput || e.input).filter(([k, v]) => typeof v !== \"undefined\" && ValidHeadTags.includes(k)).forEach(([k, value]) => {\n    const v = asArray$1(value);\n    tagPromises.push(...v.map((props) => normaliseTag(k, props)).flat());\n  });\n  return (await Promise.all(tagPromises)).flat().map((t, i) => {\n    t._e = e._i;\n    t._p = (e._i << TagEntityBits) + i;\n    return t;\n  });\n}\n\nconst CorePlugins = () => [\n  // dedupe needs to come first\n  DedupesTagsPlugin(),\n  SortTagsPlugin(),\n  TitleTemplatePlugin(),\n  ProvideTagHashPlugin(),\n  EventHandlersPlugin(),\n  DeprecatedTagAttrPlugin()\n];\nconst DOMPlugins = (options = {}) => [\n  PatchDomOnEntryUpdatesPlugin({ document: options?.document, delayFn: options?.domDelayFn })\n];\nfunction createHead$1(options = {}) {\n  const head = createHeadCore({\n    ...options,\n    plugins: [...DOMPlugins(options), ...options?.plugins || []]\n  });\n  setActiveHead(head);\n  return head;\n}\nfunction createHeadCore(options = {}) {\n  let entries = [];\n  let _sde = {};\n  let _eid = 0;\n  const hooks = createHooks();\n  if (options?.hooks)\n    hooks.addHooks(options.hooks);\n  options.plugins = [\n    ...CorePlugins(),\n    ...options?.plugins || []\n  ];\n  options.plugins.forEach((p) => p.hooks && hooks.addHooks(p.hooks));\n  const updated = () => hooks.callHook(\"entries:updated\", head);\n  const head = {\n    resolvedOptions: options,\n    headEntries() {\n      return entries;\n    },\n    get hooks() {\n      return hooks;\n    },\n    use(plugin) {\n      if (plugin.hooks)\n        hooks.addHooks(plugin.hooks);\n    },\n    push(input, options2) {\n      const activeEntry = {\n        _i: _eid++,\n        input,\n        _sde: {}\n      };\n      if (options2?.mode)\n        activeEntry._m = options2?.mode;\n      entries.push(activeEntry);\n      updated();\n      return {\n        dispose() {\n          entries = entries.filter((e) => {\n            if (e._i !== activeEntry._i)\n              return true;\n            _sde = { ..._sde, ...e._sde || {} };\n            e._sde = {};\n            updated();\n            return false;\n          });\n        },\n        // a patch is the same as creating a new entry, just a nice DX\n        patch(input2) {\n          entries = entries.map((e) => {\n            if (e._i === activeEntry._i) {\n              activeEntry.input = e.input = input2;\n              updated();\n            }\n            return e;\n          });\n        }\n      };\n    },\n    async resolveTags() {\n      const resolveCtx = { tags: [], entries: [...entries] };\n      await hooks.callHook(\"entries:resolve\", resolveCtx);\n      for (const entry of resolveCtx.entries) {\n        for (const tag of await normaliseEntryTags(entry)) {\n          const tagCtx = { tag, entry };\n          await hooks.callHook(\"tag:normalise\", tagCtx);\n          resolveCtx.tags.push(tagCtx.tag);\n        }\n      }\n      await hooks.callHook(\"tags:resolve\", resolveCtx);\n      return resolveCtx.tags;\n    },\n    _elMap: {},\n    _popSideEffectQueue() {\n      const sde = { ..._sde };\n      _sde = {};\n      return sde;\n    }\n  };\n  head.hooks.callHook(\"init\", head);\n  return head;\n}\n\nfunction defineHeadPlugin(plugin) {\n  return plugin;\n}\nconst composableNames = [\n  \"useHead\",\n  \"useTagTitle\",\n  \"useTagBase\",\n  \"useTagMeta\",\n  \"useTagMetaFlat\",\n  // alias\n  \"useSeoMeta\",\n  \"useTagLink\",\n  \"useTagScript\",\n  \"useTagStyle\",\n  \"useTagNoscript\",\n  \"useHtmlAttrs\",\n  \"useBodyAttrs\",\n  \"useTitleTemplate\",\n  // server only composables\n  \"useServerHead\",\n  \"useServerTagTitle\",\n  \"useServerTagBase\",\n  \"useServerTagMeta\",\n  \"useServerTagMetaFlat\",\n  \"useServerTagLink\",\n  \"useServerTagScript\",\n  \"useServerTagStyle\",\n  \"useServerTagNoscript\",\n  \"useServerHtmlAttrs\",\n  \"useServerBodyAttrs\",\n  \"useServerTitleTemplate\"\n];\n\nfunction resolveUnref(r) {\n  return typeof r === \"function\" ? r() : unref(r);\n}\nfunction resolveUnrefHeadInput(ref, lastKey = \"\") {\n  if (ref instanceof Promise)\n    return ref;\n  const root = resolveUnref(ref);\n  if (!ref || !root)\n    return root;\n  if (Array.isArray(root))\n    return root.map((r) => resolveUnrefHeadInput(r, lastKey));\n  if (typeof root === \"object\") {\n    let dynamic = false;\n    const unrefdObj = Object.fromEntries(\n      Object.entries(root).map(([k, v]) => {\n        if (k === \"titleTemplate\" || k.startsWith(\"on\"))\n          return [k, unref(v)];\n        if (typeof v === \"function\" || isRef(v))\n          dynamic = true;\n        return [k, resolveUnrefHeadInput(v, k)];\n      })\n    );\n    if (dynamic && HasElementTags.includes(String(lastKey)))\n      unrefdObj._dynamic = true;\n    return unrefdObj;\n  }\n  return root;\n}\nfunction asArray(value) {\n  return Array.isArray(value) ? value : [value];\n}\n\nconst Vue3 = version.startsWith(\"3\");\nconst IsBrowser = typeof window !== \"undefined\";\n\nconst headSymbol = \"usehead\";\nfunction injectHead() {\n  return getCurrentInstance() && inject(headSymbol) || getActiveHead();\n}\nfunction createHead(options = {}) {\n  const head = createHead$1({\n    ...options,\n    // arbitrary delay the dom update for batch updates\n    domDelayFn: (fn) => setTimeout(() => nextTick(() => fn()), 10),\n    plugins: [\n      VueReactiveUseHeadPlugin(),\n      ...options?.plugins || []\n    ]\n  });\n  const vuePlugin = {\n    install(app) {\n      if (Vue3) {\n        app.config.globalProperties.$unhead = head;\n        app.provide(headSymbol, head);\n      }\n    }\n  };\n  head.install = vuePlugin.install;\n  return head;\n}\n\nconst VueHeadMixin = {\n  created() {\n    const instance = getCurrentInstance();\n    if (!instance)\n      return;\n    const options = instance.type;\n    if (!options || !(\"head\" in options))\n      return;\n    const source = typeof options.head === \"function\" ? () => options.head.call(instance.proxy) : options.head;\n    useHead(source);\n  }\n};\n\nconst VueReactiveUseHeadPlugin = () => {\n  return defineHeadPlugin({\n    hooks: {\n      \"entries:resolve\": function(ctx) {\n        for (const entry of ctx.entries)\n          entry.resolvedInput = resolveUnrefHeadInput(entry.input);\n      }\n    }\n  });\n};\n\nconst Vue2ProvideUnheadPlugin = function(_Vue, head) {\n  _Vue.mixin({\n    beforeCreate() {\n      const options = this.$options;\n      const origProvide = options.provide;\n      options.provide = function() {\n        let origProvideResult;\n        if (typeof origProvide === \"function\")\n          origProvideResult = origProvide.call(this);\n        else\n          origProvideResult = origProvide || {};\n        return {\n          ...origProvideResult,\n          [headSymbol]: head\n        };\n      };\n    }\n  });\n};\n\nfunction unpackToArray(input, options) {\n  const unpacked = [];\n  const kFn = options.resolveKeyData || ((ctx) => ctx.key);\n  const vFn = options.resolveValueData || ((ctx) => ctx.value);\n  for (const [k, v] of Object.entries(input)) {\n    unpacked.push(...(Array.isArray(v) ? v : [v]).map((i) => {\n      const ctx = { key: k, value: i };\n      const val = vFn(ctx);\n      if (typeof val === \"object\")\n        return unpackToArray(val, options);\n      if (Array.isArray(val))\n        return val;\n      return {\n        [typeof options.key === \"function\" ? options.key(ctx) : options.key]: kFn(ctx),\n        [typeof options.value === \"function\" ? options.value(ctx) : options.value]: val\n      };\n    }).flat());\n  }\n  return unpacked;\n}\n\nfunction unpackToString(value, options) {\n  return Object.entries(value).map(([key, value2]) => {\n    if (typeof value2 === \"object\")\n      value2 = unpackToString(value2, options);\n    if (options.resolve) {\n      const resolved = options.resolve({ key, value: value2 });\n      if (resolved)\n        return resolved;\n    }\n    if (typeof value2 === \"number\")\n      value2 = value2.toString();\n    if (typeof value2 === \"string\" && options.wrapValue) {\n      value2 = value2.replace(new RegExp(options.wrapValue, \"g\"), `\\\\${options.wrapValue}`);\n      value2 = `${options.wrapValue}${value2}${options.wrapValue}`;\n    }\n    return `${key}${options.keyValueSeparator || \"\"}${value2}`;\n  }).join(options.entrySeparator || \"\");\n}\n\nconst MetaPackingSchema = {\n  robots: {\n    unpack: {\n      keyValueSeparator: \":\"\n    }\n  },\n  contentSecurityPolicy: {\n    unpack: {\n      keyValueSeparator: \" \",\n      entrySeparator: \"; \"\n    },\n    metaKey: \"http-equiv\"\n  },\n  fbAppId: {\n    keyValue: \"fb:app_id\",\n    metaKey: \"property\"\n  },\n  msapplicationTileImage: {\n    keyValue: \"msapplication-TileImage\"\n  },\n  msapplicationTileColor: {\n    keyValue: \"msapplication-TileColor\"\n  },\n  msapplicationConfig: {\n    keyValue: \"msapplication-Config\"\n  },\n  charset: {\n    metaKey: \"charset\"\n  },\n  contentType: {\n    metaKey: \"http-equiv\"\n  },\n  defaultStyle: {\n    metaKey: \"http-equiv\"\n  },\n  xUaCompatible: {\n    metaKey: \"http-equiv\"\n  },\n  refresh: {\n    metaKey: \"http-equiv\"\n  }\n};\nfunction resolveMetaKeyType(key) {\n  return PropertyPrefixKeys.test(key) ? \"property\" : MetaPackingSchema[key]?.metaKey || \"name\";\n}\n\nfunction unpackMeta(input) {\n  const meta = unpackToArray(input, {\n    key({ key }) {\n      return resolveMetaKeyType(key);\n    },\n    value({ key }) {\n      return key === \"charset\" ? \"charset\" : \"content\";\n    },\n    resolveKeyData({ key }) {\n      return MetaPackingSchema[key]?.keyValue || fixKeyCase(key);\n    },\n    resolveValueData({ value, key }) {\n      if (value === null)\n        return \"_null\";\n      if (typeof value === \"object\") {\n        const definition = MetaPackingSchema[key];\n        if (key === \"refresh\")\n          return `${value.seconds};url=${value.url}`;\n        return unpackToString(\n          changeKeyCasingDeep(value),\n          {\n            entrySeparator: \", \",\n            keyValueSeparator: \"=\",\n            resolve({ value: value2, key: key2 }) {\n              if (value2 === null)\n                return \"\";\n              if (typeof value2 === \"boolean\")\n                return `${key2}`;\n            },\n            ...definition?.unpack\n          }\n        );\n      }\n      return typeof value === \"number\" ? value.toString() : value;\n    }\n  });\n  return meta.filter((v) => typeof v.content === \"undefined\" || v.content !== \"_null\");\n}\n\nconst PropertyPrefixKeys = /^(og|twitter|fb)/;\nfunction fixKeyCase(key) {\n  key = key.replace(/([A-Z])/g, \"-$1\").toLowerCase();\n  if (PropertyPrefixKeys.test(key)) {\n    key = key.replace(\"secure-url\", \"secure_url\").replace(/-/g, \":\");\n  }\n  return key;\n}\nfunction changeKeyCasingDeep(input) {\n  if (Array.isArray(input)) {\n    return input.map((entry) => changeKeyCasingDeep(entry));\n  }\n  if (typeof input !== \"object\" || Array.isArray(input))\n    return input;\n  const output = {};\n  for (const [key, value] of Object.entries(input))\n    output[fixKeyCase(key)] = changeKeyCasingDeep(value);\n  return output;\n}\n\nfunction clientUseHead(input, options = {}) {\n  const head = injectHead();\n  const resolvedInput = ref({});\n  watchEffect(() => {\n    resolvedInput.value = resolveUnrefHeadInput(input);\n  });\n  const entry = head.push(resolvedInput.value, options);\n  watch(resolvedInput, (e) => entry.patch(e));\n  const vm = getCurrentInstance();\n  if (vm) {\n    onBeforeUnmount(() => {\n      entry.dispose();\n    });\n  }\n  return entry;\n}\n\nfunction serverUseHead(input, options = {}) {\n  const head = injectHead();\n  return head.push(input, options);\n}\n\nfunction useServerHead(input, options = {}) {\n  return useHead(input, { ...options, mode: \"server\" });\n}\nconst useServerTagTitle = (title) => useServerHead({ title });\nconst useServerTitleTemplate = (titleTemplate) => useServerHead({ titleTemplate });\nconst useServerTagMeta = (meta) => useServerHead({ meta: asArray(meta) });\nconst useServerTagMetaFlat = (meta) => {\n  const input = ref({});\n  watchEffect(() => {\n    input.value = unpackMeta(resolveUnrefHeadInput(meta));\n  });\n  return useServerHead({ meta: input });\n};\nconst useServerTagLink = (link) => useServerHead({ link: asArray(link) });\nconst useServerTagScript = (script) => useServerHead({ script: asArray(script) });\nconst useServerTagStyle = (style) => useServerHead({ style: asArray(style) });\nconst useServerTagNoscript = (noscript) => useServerHead({ noscript: asArray(noscript) });\nconst useServerTagBase = (base) => useServerHead({ base });\nconst useServerHtmlAttrs = (attrs) => useServerHead({ htmlAttrs: attrs });\nconst useServerBodyAttrs = (attrs) => useHead({ bodyAttrs: attrs });\n\nconst useSeoMeta = (input) => {\n  const headInput = ref({});\n  watchEffect(() => {\n    const resolvedMeta = resolveUnrefHeadInput(input);\n    const { title, titleTemplate, ...meta } = resolvedMeta;\n    headInput.value = {\n      title,\n      titleTemplate,\n      meta: unpackMeta(meta)\n    };\n  });\n  return useHead(headInput);\n};\n\nfunction useHead(input, options = {}) {\n  const head = injectHead();\n  if (head) {\n    const isBrowser = IsBrowser || !!head.resolvedOptions?.document;\n    if (options.mode === \"server\" && isBrowser || options.mode === \"client\" && !isBrowser)\n      return;\n    return isBrowser ? clientUseHead(input, options) : serverUseHead(input, options);\n  }\n}\nconst useTagTitle = (title) => useHead({ title });\nconst useTitleTemplate = (titleTemplate) => useHead({ titleTemplate });\nconst useTagMeta = (meta) => useHead({ meta: asArray(meta) });\nconst useTagMetaFlat = (meta) => {\n  const input = ref({});\n  watchEffect(() => {\n    input.value = unpackMeta(resolveUnrefHeadInput(meta));\n  });\n  return useHead({ meta: input });\n};\nconst useTagLink = (link) => useHead({ link: asArray(link) });\nconst useTagScript = (script) => useHead({ script: asArray(script) });\nconst useTagStyle = (style) => useHead({ style: asArray(style) });\nconst useTagNoscript = (noscript) => useHead({ noscript: asArray(noscript) });\nconst useTagBase = (base) => useHead({ base });\nconst useHtmlAttrs = (attrs) => useHead({ htmlAttrs: attrs });\nconst useBodyAttrs = (attrs) => useHead({ bodyAttrs: attrs });\n\nconst coreComposableNames = [\n  \"injectHead\"\n];\nconst unheadVueComposablesImports = {\n  \"@unhead/vue\": [...coreComposableNames, ...composableNames]\n};\n\nexport { Vue2ProvideUnheadPlugin, VueHeadMixin, VueReactiveUseHeadPlugin, asArray, createHead, createHeadCore, headSymbol, injectHead, resolveUnrefHeadInput, unheadVueComposablesImports, useBodyAttrs, useHead, useHtmlAttrs, useSeoMeta, useServerBodyAttrs, useServerHead, useServerHtmlAttrs, useServerTagBase, useServerTagLink, useServerTagMeta, useServerTagMetaFlat, useServerTagNoscript, useServerTagScript, useServerTagStyle, useServerTagTitle, useServerTitleTemplate, useTagBase, useTagLink, useTagMeta, useTagMetaFlat, useTagNoscript, useTagScript, useTagStyle, useTagTitle, useTitleTemplate };\n", "import { createHead as createHead$1, useHead, Vue2ProvideUnheadPlugin, injectHead } from '@unhead/vue';\nexport { Vue2ProvideUnheadPlugin, VueHeadMixin, createHeadCore, injectHead, unheadVueComposablesImports, useBodyAttrs, useHead, useHtmlAttrs, useSeoMeta, useServerBodyAttrs, useServerHead, useServerHtmlAttrs, useServerTagBase, useServerTagLink, useServerTagMeta, useServerTagMetaFlat, useServerTagNoscript, useServerTagScript, useServerTagStyle, useServerTagTitle, useServerTitleTemplate, useTagBase, useTagLink, useTagMeta, useTagMetaFlat, useTagNoscript, useTagScript, useTagStyle, useTagTitle, useTitleTemplate } from '@unhead/vue';\nimport { renderDOMHead, debouncedRenderDOMHead } from '@unhead/dom';\nimport { version, defineComponent, ref, onBeforeUnmount, watchEffect } from 'vue';\nimport { renderSSRHead } from '@unhead/ssr';\n\nfunction createHead(initHeadObject) {\n  const unhead = createHead$1();\n  const legacyHead = {\n    unhead,\n    install(app) {\n      if (version.startsWith(\"3\")) {\n        app.config.globalProperties.$head = unhead;\n        app.provide(\"usehead\", unhead);\n      }\n    },\n    use(plugin) {\n      unhead.use(plugin);\n    },\n    resolveTags() {\n      return unhead.resolveTags();\n    },\n    headEntries() {\n      return unhead.headEntries();\n    },\n    headTags() {\n      return unhead.resolveTags();\n    },\n    push(input, options) {\n      return unhead.push(input, options);\n    },\n    addEntry(input, options) {\n      return unhead.push(input, options);\n    },\n    addHeadObjs(input, options) {\n      return unhead.push(input, options);\n    },\n    addReactiveEntry(input, options) {\n      const api = useHead(input, options);\n      if (typeof api !== \"undefined\")\n        return api.dispose;\n      return () => {\n      };\n    },\n    removeHeadObjs() {\n    },\n    updateDOM(document, force) {\n      if (force)\n        renderDOMHead(unhead, { document });\n      else\n        debouncedRenderDOMHead(unhead, { delayFn: (fn) => setTimeout(() => fn(), 50), document });\n    },\n    internalHooks: unhead.hooks,\n    hooks: {\n      \"before:dom\": [],\n      \"resolved:tags\": [],\n      \"resolved:entries\": []\n    }\n  };\n  unhead.addHeadObjs = legacyHead.addHeadObjs;\n  unhead.updateDOM = legacyHead.updateDOM;\n  unhead.hooks.hook(\"dom:beforeRender\", (ctx) => {\n    for (const hook of legacyHead.hooks[\"before:dom\"]) {\n      if (hook() === false)\n        ctx.shouldRender = false;\n    }\n  });\n  if (initHeadObject)\n    legacyHead.addHeadObjs(initHeadObject);\n  return legacyHead;\n}\n\nconst HeadVuePlugin = Vue2ProvideUnheadPlugin;\nconst renderHeadToString = (head) => renderSSRHead(head.unhead);\n\nconst Vue2 = version.startsWith(\"2.\");\nconst IsBrowser = typeof window !== \"undefined\";\n\nconst addVNodeToHeadObj = (node, obj) => {\n  const nodeType = Vue2 ? node.tag : node.type;\n  const type = nodeType === \"html\" ? \"htmlAttrs\" : nodeType === \"body\" ? \"bodyAttrs\" : nodeType;\n  if (typeof type !== \"string\" || !(type in obj))\n    return;\n  const nodeData = Vue2 ? node.data : node;\n  const props = (Vue2 ? nodeData.attrs : node.props) || {};\n  if (Vue2) {\n    if (nodeData.staticClass)\n      props.class = nodeData.staticClass;\n    if (nodeData.staticStyle)\n      props.style = Object.entries(nodeData.staticStyle).map(([key, value]) => `${key}:${value}`).join(\";\");\n  }\n  if (node.children) {\n    const childrenAttr = Vue2 ? \"text\" : \"children\";\n    props.children = Array.isArray(node.children) ? node.children[0][childrenAttr] : node[childrenAttr];\n  }\n  if (Array.isArray(obj[type]))\n    obj[type].push(props);\n  else if (type === \"title\")\n    obj.title = props.children;\n  else\n    obj[type] = props;\n};\nconst vnodesToHeadObj = (nodes) => {\n  const obj = {\n    title: void 0,\n    htmlAttrs: void 0,\n    bodyAttrs: void 0,\n    base: void 0,\n    meta: [],\n    link: [],\n    style: [],\n    script: [],\n    noscript: []\n  };\n  for (const node of nodes) {\n    if (typeof node.type === \"symbol\" && Array.isArray(node.children)) {\n      for (const childNode of node.children)\n        addVNodeToHeadObj(childNode, obj);\n    } else {\n      addVNodeToHeadObj(node, obj);\n    }\n  }\n  return obj;\n};\nconst Head = /* @__PURE__ */ defineComponent({\n  // eslint-disable-next-line vue/no-reserved-component-names\n  name: \"Head\",\n  setup(_, { slots }) {\n    const head = injectHead();\n    const obj = ref({});\n    const entry = head.push(obj);\n    if (IsBrowser) {\n      onBeforeUnmount(() => {\n        entry.dispose();\n      });\n    }\n    return () => {\n      watchEffect(() => {\n        if (!slots.default)\n          return;\n        entry.patch(vnodesToHeadObj(slots.default()));\n      });\n      return null;\n    };\n  }\n});\n\nexport { Head, HeadVuePlugin, createHead, renderHeadToString };\n", "import { useSeoMeta as _useSeoMeta } from \"@vueuse/head\";\nimport { useNuxtApp } from \"#app\";\nexport function useHead(input, options) {\n  return useNuxtApp()._useHead(input, options);\n}\nexport const useSeoMeta = (meta) => {\n  return _useSeoMeta(meta);\n};\nexport const useServerSeoMeta = (meta) => {\n  if (process.server) {\n    return _useSeoMeta(meta);\n  }\n};\n", "import { getCurrentInstance, reactive, toRefs } from \"vue\";\nimport { useNuxtApp } from \"../nuxt.mjs\";\nimport { useAsyncData } from \"./asyncData.mjs\";\nimport { useRoute } from \"./router.mjs\";\nimport { useHead } from \"#head\";\nexport const NuxtComponentIndicator = \"__nuxt_component\";\nasync function runLegacyAsyncData(res, fn) {\n  const nuxt = useNuxtApp();\n  const route = useRoute();\n  const vm = getCurrentInstance();\n  const { fetchKey } = vm.proxy.$options;\n  const key = typeof fetchKey === \"function\" ? fetchKey(() => \"\") : fetchKey || route.fullPath;\n  const { data } = await useAsyncData(`options:asyncdata:${key}`, () => fn(nuxt));\n  if (data.value && typeof data.value === \"object\") {\n    Object.assign(await res, toRefs(reactive(data.value)));\n  } else if (process.dev) {\n    console.warn(\"[nuxt] asyncData should return an object\", data);\n  }\n}\nexport const defineNuxtComponent = function defineNuxtComponent2(options) {\n  const { setup } = options;\n  if (!setup && !options.asyncData && !options.head) {\n    return {\n      [NuxtComponentIndicator]: true,\n      ...options\n    };\n  }\n  return {\n    [NuxtComponentIndicator]: true,\n    ...options,\n    setup(props, ctx) {\n      const res = setup?.(props, ctx) || {};\n      const promises = [];\n      if (options.asyncData) {\n        promises.push(runLegacyAsyncData(res, options.asyncData));\n      }\n      if (options.head) {\n        const nuxtApp = useNuxtApp();\n        useHead(typeof options.head === \"function\" ? () => options.head(nuxtApp) : options.head);\n      }\n      return Promise.resolve(res).then(() => Promise.all(promises)).then(() => res).finally(() => {\n        promises.length = 0;\n      });\n    }\n  };\n};\n", "import { useNuxtApp } from \"../nuxt.mjs\";\nexport const useHydration = (key, get, set) => {\n  const nuxt = useNuxtApp();\n  if (process.server) {\n    nuxt.hooks.hook(\"app:rendered\", () => {\n      nuxt.payload[key] = get();\n    });\n  }\n  if (process.client) {\n    nuxt.hooks.hook(\"app:created\", () => {\n      set(nuxt.payload[key]);\n    });\n  }\n};\n", "const defaults = {\n  ignoreUnknown: false,\n  respectType: false,\n  respectFunctionNames: false,\n  respectFunctionProperties: false,\n  unorderedObjects: true,\n  unorderedArrays: false,\n  unorderedSets: false\n};\nfunction objectHash(object, options = {}) {\n  options = { ...defaults, ...options };\n  const hasher = createHasher(options);\n  hasher.dispatch(object);\n  return hasher.toString();\n}\nfunction createHasher(options) {\n  const buff = [];\n  let context = [];\n  const write = (str) => {\n    buff.push(str);\n  };\n  return {\n    toString() {\n      return buff.join(\"\");\n    },\n    getContext() {\n      return context;\n    },\n    dispatch(value) {\n      if (options.replacer) {\n        value = options.replacer(value);\n      }\n      const type = value === null ? \"null\" : typeof value;\n      return this[\"_\" + type](value);\n    },\n    _object(object) {\n      const pattern = /\\[object (.*)]/i;\n      const objString = Object.prototype.toString.call(object);\n      const _objType = pattern.exec(objString);\n      const objType = _objType ? _objType[1].toLowerCase() : \"unknown:[\" + objString.toLowerCase() + \"]\";\n      let objectNumber = null;\n      if ((objectNumber = context.indexOf(object)) >= 0) {\n        return this.dispatch(\"[CIRCULAR:\" + objectNumber + \"]\");\n      } else {\n        context.push(object);\n      }\n      if (typeof Buffer !== \"undefined\" && Buffer.isBuffer && Buffer.isBuffer(object)) {\n        write(\"buffer:\");\n        return write(object.toString(\"utf8\"));\n      }\n      if (objType !== \"object\" && objType !== \"function\" && objType !== \"asyncfunction\") {\n        if (this[\"_\" + objType]) {\n          this[\"_\" + objType](object);\n        } else if (options.ignoreUnknown) {\n          return write(\"[\" + objType + \"]\");\n        } else {\n          throw new Error('Unknown object type \"' + objType + '\"');\n        }\n      } else {\n        let keys = Object.keys(object);\n        if (options.unorderedObjects) {\n          keys = keys.sort();\n        }\n        if (options.respectType !== false && !isNativeFunction(object)) {\n          keys.splice(0, 0, \"prototype\", \"__proto__\", \"letructor\");\n        }\n        if (options.excludeKeys) {\n          keys = keys.filter(function(key) {\n            return !options.excludeKeys(key);\n          });\n        }\n        write(\"object:\" + keys.length + \":\");\n        for (const key of keys) {\n          this.dispatch(key);\n          write(\":\");\n          if (!options.excludeValues) {\n            this.dispatch(object[key]);\n          }\n          write(\",\");\n        }\n      }\n    },\n    _array(arr, unordered) {\n      unordered = typeof unordered !== \"undefined\" ? unordered : options.unorderedArrays !== false;\n      write(\"array:\" + arr.length + \":\");\n      if (!unordered || arr.length <= 1) {\n        for (const entry of arr) {\n          this.dispatch(entry);\n        }\n        return;\n      }\n      const contextAdditions = [];\n      const entries = arr.map((entry) => {\n        const hasher = createHasher(options);\n        hasher.dispatch(entry);\n        contextAdditions.push(hasher.getContext());\n        return hasher.toString();\n      });\n      context = [...context, ...contextAdditions];\n      entries.sort();\n      return this._array(entries, false);\n    },\n    _date(date) {\n      return write(\"date:\" + date.toJSON());\n    },\n    _symbol(sym) {\n      return write(\"symbol:\" + sym.toString());\n    },\n    _error(err) {\n      return write(\"error:\" + err.toString());\n    },\n    _boolean(bool) {\n      return write(\"bool:\" + bool.toString());\n    },\n    _string(string) {\n      write(\"string:\" + string.length + \":\");\n      write(string.toString());\n    },\n    _function(fn) {\n      write(\"fn:\");\n      if (isNativeFunction(fn)) {\n        this.dispatch(\"[native]\");\n      } else {\n        this.dispatch(fn.toString());\n      }\n      if (options.respectFunctionNames !== false) {\n        this.dispatch(\"function-name:\" + String(fn.name));\n      }\n      if (options.respectFunctionProperties) {\n        this._object(fn);\n      }\n    },\n    _number(number) {\n      return write(\"number:\" + number.toString());\n    },\n    _xml(xml) {\n      return write(\"xml:\" + xml.toString());\n    },\n    _null() {\n      return write(\"Null\");\n    },\n    _undefined() {\n      return write(\"Undefined\");\n    },\n    _regexp(regex) {\n      return write(\"regex:\" + regex.toString());\n    },\n    _uint8array(arr) {\n      write(\"uint8array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    _uint8clampedarray(arr) {\n      write(\"uint8clampedarray:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    _int8array(arr) {\n      write(\"int8array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    _uint16array(arr) {\n      write(\"uint16array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    _int16array(arr) {\n      write(\"int16array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    _uint32array(arr) {\n      write(\"uint32array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    _int32array(arr) {\n      write(\"int32array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    _float32array(arr) {\n      write(\"float32array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    _float64array(arr) {\n      write(\"float64array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    _arraybuffer(arr) {\n      write(\"arraybuffer:\");\n      return this.dispatch(new Uint8Array(arr));\n    },\n    _url(url) {\n      return write(\"url:\" + url.toString());\n    },\n    _map(map) {\n      write(\"map:\");\n      const arr = [...map];\n      return this._array(arr, options.unorderedSets !== false);\n    },\n    _set(set) {\n      write(\"set:\");\n      const arr = [...set];\n      return this._array(arr, options.unorderedSets !== false);\n    },\n    _file(file) {\n      write(\"file:\");\n      return this.dispatch([file.name, file.size, file.type, file.lastModfied]);\n    },\n    _blob() {\n      if (options.ignoreUnknown) {\n        return write(\"[blob]\");\n      }\n      throw new Error('Hashing Blob objects is currently not supported\\nUse \"options.replacer\" or \"options.ignoreUnknown\"\\n');\n    },\n    _domwindow() {\n      return write(\"domwindow\");\n    },\n    _bigint(number) {\n      return write(\"bigint:\" + number.toString());\n    },\n    _process() {\n      return write(\"process\");\n    },\n    _timer() {\n      return write(\"timer\");\n    },\n    _pipe() {\n      return write(\"pipe\");\n    },\n    _tcp() {\n      return write(\"tcp\");\n    },\n    _udp() {\n      return write(\"udp\");\n    },\n    _tty() {\n      return write(\"tty\");\n    },\n    _statwatcher() {\n      return write(\"statwatcher\");\n    },\n    _securecontext() {\n      return write(\"securecontext\");\n    },\n    _connection() {\n      return write(\"connection\");\n    },\n    _zlib() {\n      return write(\"zlib\");\n    },\n    _context() {\n      return write(\"context\");\n    },\n    _nodescript() {\n      return write(\"nodescript\");\n    },\n    _httpparser() {\n      return write(\"httpparser\");\n    },\n    _dataview() {\n      return write(\"dataview\");\n    },\n    _signal() {\n      return write(\"signal\");\n    },\n    _fsevent() {\n      return write(\"fsevent\");\n    },\n    _tlswrap() {\n      return write(\"tlswrap\");\n    }\n  };\n}\nfunction isNativeFunction(f) {\n  if (typeof f !== \"function\") {\n    return false;\n  }\n  const exp = /^function\\s+\\w*\\s*\\(\\s*\\)\\s*{\\s+\\[native code]\\s+}$/i;\n  return exp.exec(Function.prototype.toString.call(f)) != null;\n}\n\nclass WordArray {\n  constructor(words, sigBytes) {\n    words = this.words = words || [];\n    this.sigBytes = sigBytes !== void 0 ? sigBytes : words.length * 4;\n  }\n  toString(encoder) {\n    return (encoder || Hex).stringify(this);\n  }\n  concat(wordArray) {\n    this.clamp();\n    if (this.sigBytes % 4) {\n      for (let i = 0; i < wordArray.sigBytes; i++) {\n        const thatByte = wordArray.words[i >>> 2] >>> 24 - i % 4 * 8 & 255;\n        this.words[this.sigBytes + i >>> 2] |= thatByte << 24 - (this.sigBytes + i) % 4 * 8;\n      }\n    } else {\n      for (let j = 0; j < wordArray.sigBytes; j += 4) {\n        this.words[this.sigBytes + j >>> 2] = wordArray.words[j >>> 2];\n      }\n    }\n    this.sigBytes += wordArray.sigBytes;\n    return this;\n  }\n  clamp() {\n    this.words[this.sigBytes >>> 2] &= 4294967295 << 32 - this.sigBytes % 4 * 8;\n    this.words.length = Math.ceil(this.sigBytes / 4);\n  }\n  clone() {\n    return new WordArray([...this.words]);\n  }\n}\nconst Hex = {\n  stringify(wordArray) {\n    const hexChars = [];\n    for (let i = 0; i < wordArray.sigBytes; i++) {\n      const bite = wordArray.words[i >>> 2] >>> 24 - i % 4 * 8 & 255;\n      hexChars.push(\n        (bite >>> 4).toString(16),\n        (bite & 15).toString(16)\n      );\n    }\n    return hexChars.join(\"\");\n  }\n};\nconst Base64 = {\n  stringify(wordArray) {\n    const keyStr = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n    const base64Chars = [];\n    for (let i = 0; i < wordArray.sigBytes; i += 3) {\n      const byte1 = wordArray.words[i >>> 2] >>> 24 - i % 4 * 8 & 255;\n      const byte2 = wordArray.words[i + 1 >>> 2] >>> 24 - (i + 1) % 4 * 8 & 255;\n      const byte3 = wordArray.words[i + 2 >>> 2] >>> 24 - (i + 2) % 4 * 8 & 255;\n      const triplet = byte1 << 16 | byte2 << 8 | byte3;\n      for (let j = 0; j < 4 && i * 8 + j * 6 < wordArray.sigBytes * 8; j++) {\n        base64Chars.push(keyStr.charAt(triplet >>> 6 * (3 - j) & 63));\n      }\n    }\n    return base64Chars.join(\"\");\n  }\n};\nconst Latin1 = {\n  parse(latin1Str) {\n    const latin1StrLength = latin1Str.length;\n    const words = [];\n    for (let i = 0; i < latin1StrLength; i++) {\n      words[i >>> 2] |= (latin1Str.charCodeAt(i) & 255) << 24 - i % 4 * 8;\n    }\n    return new WordArray(words, latin1StrLength);\n  }\n};\nconst Utf8 = {\n  parse(utf8Str) {\n    return Latin1.parse(unescape(encodeURIComponent(utf8Str)));\n  }\n};\nclass BufferedBlockAlgorithm {\n  constructor() {\n    this._minBufferSize = 0;\n    this.blockSize = 512 / 32;\n    this.reset();\n  }\n  reset() {\n    this._data = new WordArray();\n    this._nDataBytes = 0;\n  }\n  _append(data) {\n    if (typeof data === \"string\") {\n      data = Utf8.parse(data);\n    }\n    this._data.concat(data);\n    this._nDataBytes += data.sigBytes;\n  }\n  _doProcessBlock(_dataWords, _offset) {\n  }\n  _process(doFlush) {\n    let processedWords;\n    let nBlocksReady = this._data.sigBytes / (this.blockSize * 4);\n    if (doFlush) {\n      nBlocksReady = Math.ceil(nBlocksReady);\n    } else {\n      nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);\n    }\n    const nWordsReady = nBlocksReady * this.blockSize;\n    const nBytesReady = Math.min(nWordsReady * 4, this._data.sigBytes);\n    if (nWordsReady) {\n      for (let offset = 0; offset < nWordsReady; offset += this.blockSize) {\n        this._doProcessBlock(this._data.words, offset);\n      }\n      processedWords = this._data.words.splice(0, nWordsReady);\n      this._data.sigBytes -= nBytesReady;\n    }\n    return new WordArray(processedWords, nBytesReady);\n  }\n}\nclass Hasher extends BufferedBlockAlgorithm {\n  update(messageUpdate) {\n    this._append(messageUpdate);\n    this._process();\n    return this;\n  }\n  finalize(messageUpdate) {\n    if (messageUpdate) {\n      this._append(messageUpdate);\n    }\n  }\n}\n\nconst H = [1779033703, -1150833019, 1013904242, -1521486534, 1359893119, -1694144372, 528734635, 1541459225];\nconst K = [1116352408, 1899447441, -1245643825, -373957723, 961987163, 1508970993, -1841331548, -1424204075, -670586216, 310598401, 607225278, 1426881987, 1925078388, -2132889090, -1680079193, -1046744716, -459576895, -272742522, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, -1740746414, -1473132947, -1341970488, -1084653625, -958395405, -710438585, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, -2117940946, -1838011259, -1564481375, -1474664885, -1035236496, -949202525, -778901479, -694614492, -200395387, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, -2067236844, -1933114872, -1866530822, -1538233109, -1090935817, -965641998];\nconst W = [];\nclass SHA256 extends Hasher {\n  constructor() {\n    super();\n    this.reset();\n  }\n  reset() {\n    super.reset();\n    this._hash = new WordArray([...H]);\n  }\n  _doProcessBlock(M, offset) {\n    const H2 = this._hash.words;\n    let a = H2[0];\n    let b = H2[1];\n    let c = H2[2];\n    let d = H2[3];\n    let e = H2[4];\n    let f = H2[5];\n    let g = H2[6];\n    let h = H2[7];\n    for (let i = 0; i < 64; i++) {\n      if (i < 16) {\n        W[i] = M[offset + i] | 0;\n      } else {\n        const gamma0x = W[i - 15];\n        const gamma0 = (gamma0x << 25 | gamma0x >>> 7) ^ (gamma0x << 14 | gamma0x >>> 18) ^ gamma0x >>> 3;\n        const gamma1x = W[i - 2];\n        const gamma1 = (gamma1x << 15 | gamma1x >>> 17) ^ (gamma1x << 13 | gamma1x >>> 19) ^ gamma1x >>> 10;\n        W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];\n      }\n      const ch = e & f ^ ~e & g;\n      const maj = a & b ^ a & c ^ b & c;\n      const sigma0 = (a << 30 | a >>> 2) ^ (a << 19 | a >>> 13) ^ (a << 10 | a >>> 22);\n      const sigma1 = (e << 26 | e >>> 6) ^ (e << 21 | e >>> 11) ^ (e << 7 | e >>> 25);\n      const t1 = h + sigma1 + ch + K[i] + W[i];\n      const t2 = sigma0 + maj;\n      h = g;\n      g = f;\n      f = e;\n      e = d + t1 | 0;\n      d = c;\n      c = b;\n      b = a;\n      a = t1 + t2 | 0;\n    }\n    H2[0] = H2[0] + a | 0;\n    H2[1] = H2[1] + b | 0;\n    H2[2] = H2[2] + c | 0;\n    H2[3] = H2[3] + d | 0;\n    H2[4] = H2[4] + e | 0;\n    H2[5] = H2[5] + f | 0;\n    H2[6] = H2[6] + g | 0;\n    H2[7] = H2[7] + h | 0;\n  }\n  finalize(messageUpdate) {\n    super.finalize(messageUpdate);\n    const nBitsTotal = this._nDataBytes * 8;\n    const nBitsLeft = this._data.sigBytes * 8;\n    this._data.words[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;\n    this._data.words[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math.floor(nBitsTotal / 4294967296);\n    this._data.words[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;\n    this._data.sigBytes = this._data.words.length * 4;\n    this._process();\n    return this._hash;\n  }\n}\nfunction sha256(message) {\n  return new SHA256().finalize(message).toString();\n}\nfunction sha256base64(message) {\n  return new SHA256().finalize(message).toString(Base64);\n}\n\nfunction hash(object, options = {}) {\n  const hashed = typeof object === \"string\" ? object : objectHash(object, options);\n  return sha256base64(hashed).slice(0, 10);\n}\n\nfunction murmurHash(key, seed = 0) {\n  if (typeof key === \"string\") {\n    key = createBuffer(key);\n  }\n  let i = 0;\n  let h1 = seed;\n  let k1;\n  let h1b;\n  const remainder = key.length & 3;\n  const bytes = key.length - remainder;\n  const c1 = 3432918353;\n  const c2 = 461845907;\n  while (i < bytes) {\n    k1 = key[i] & 255 | (key[++i] & 255) << 8 | (key[++i] & 255) << 16 | (key[++i] & 255) << 24;\n    ++i;\n    k1 = (k1 & 65535) * c1 + (((k1 >>> 16) * c1 & 65535) << 16) & 4294967295;\n    k1 = k1 << 15 | k1 >>> 17;\n    k1 = (k1 & 65535) * c2 + (((k1 >>> 16) * c2 & 65535) << 16) & 4294967295;\n    h1 ^= k1;\n    h1 = h1 << 13 | h1 >>> 19;\n    h1b = (h1 & 65535) * 5 + (((h1 >>> 16) * 5 & 65535) << 16) & 4294967295;\n    h1 = (h1b & 65535) + 27492 + (((h1b >>> 16) + 58964 & 65535) << 16);\n  }\n  k1 = 0;\n  switch (remainder) {\n    case 3:\n      k1 ^= (key[i + 2] & 255) << 16;\n      break;\n    case 2:\n      k1 ^= (key[i + 1] & 255) << 8;\n      break;\n    case 1:\n      k1 ^= key[i] & 255;\n      k1 = (k1 & 65535) * c1 + (((k1 >>> 16) * c1 & 65535) << 16) & 4294967295;\n      k1 = k1 << 15 | k1 >>> 17;\n      k1 = (k1 & 65535) * c2 + (((k1 >>> 16) * c2 & 65535) << 16) & 4294967295;\n      h1 ^= k1;\n  }\n  h1 ^= key.length;\n  h1 ^= h1 >>> 16;\n  h1 = (h1 & 65535) * 2246822507 + (((h1 >>> 16) * 2246822507 & 65535) << 16) & 4294967295;\n  h1 ^= h1 >>> 13;\n  h1 = (h1 & 65535) * 3266489909 + (((h1 >>> 16) * 3266489909 & 65535) << 16) & 4294967295;\n  h1 ^= h1 >>> 16;\n  return h1 >>> 0;\n}\nfunction createBuffer(val) {\n  return new TextEncoder().encode(val);\n}\n\nfunction isEqual(object1, object2, hashOptions = {}) {\n  if (object1 === object2) {\n    return true;\n  }\n  if (objectHash(object1, hashOptions) === objectHash(object2, hashOptions)) {\n    return true;\n  }\n  return false;\n}\n\nexport { hash, isEqual, murmurHash, objectHash, sha256 };\n", "import { computed, unref, reactive } from \"vue\";\nimport { hash } from \"ohash\";\nimport { useAsyncData } from \"./asyncData.mjs\";\nexport function useFetch(request, arg1, arg2) {\n  const [opts = {}, autoKey] = typeof arg1 === \"string\" ? [{}, arg1] : [arg1, arg2];\n  const _key = opts.key || hash([autoKey, unref(opts.baseURL), typeof request === \"string\" ? request : \"\", unref(opts.params || opts.query)]);\n  if (!_key || typeof _key !== \"string\") {\n    throw new TypeError(\"[nuxt] [useFetch] key must be a string: \" + _key);\n  }\n  if (!request) {\n    throw new Error(\"[nuxt] [useFetch] request is missing.\");\n  }\n  const key = _key === autoKey ? \"$f\" + _key : _key;\n  const _request = computed(() => {\n    let r = request;\n    if (typeof r === \"function\") {\n      r = r();\n    }\n    return unref(r);\n  });\n  const {\n    server,\n    lazy,\n    default: defaultFn,\n    transform,\n    pick,\n    watch,\n    immediate,\n    ...fetchOptions\n  } = opts;\n  const _fetchOptions = reactive({\n    ...fetchOptions,\n    cache: typeof opts.cache === \"boolean\" ? void 0 : opts.cache\n  });\n  const _asyncDataOptions = {\n    server,\n    lazy,\n    default: defaultFn,\n    transform,\n    pick,\n    immediate,\n    watch: [\n      _fetchOptions,\n      _request,\n      ...watch || []\n    ]\n  };\n  let controller;\n  const asyncData = useAsyncData(key, () => {\n    controller?.abort?.();\n    controller = typeof AbortController !== \"undefined\" ? new AbortController() : {};\n    return $fetch(_request.value, { signal: controller.signal, ..._fetchOptions });\n  }, _asyncDataOptions);\n  return asyncData;\n}\nexport function useLazyFetch(request, arg1, arg2) {\n  const [opts, autoKey] = typeof arg1 === \"string\" ? [{}, arg1] : [arg1, arg2];\n  return useFetch(\n    request,\n    {\n      ...opts,\n      lazy: true\n    },\n    // @ts-ignore\n    autoKey\n  );\n}\n", "import { ref, watch } from \"vue\";\nimport { parse, serialize } from \"cookie-es\";\nimport { appendHeader } from \"h3\";\nimport destr from \"destr\";\nimport { isEqual } from \"ohash\";\nimport { useNuxtApp } from \"../nuxt.mjs\";\nimport { useRequestEvent } from \"./ssr.mjs\";\nconst CookieDefaults = {\n  path: \"/\",\n  watch: true,\n  decode: (val) => destr(decodeURIComponent(val)),\n  encode: (val) => encodeURIComponent(typeof val === \"string\" ? val : JSON.stringify(val))\n};\nexport function useCookie(name, _opts) {\n  const opts = { ...CookieDefaults, ..._opts };\n  const cookies = readRawCookies(opts) || {};\n  const cookie = ref(cookies[name] ?? opts.default?.());\n  if (process.client) {\n    const callback = () => {\n      writeClientCookie(name, cookie.value, opts);\n    };\n    if (opts.watch) {\n      watch(cookie, callback, { deep: opts.watch !== \"shallow\" });\n    } else {\n      callback();\n    }\n  } else if (process.server) {\n    const nuxtApp = useNuxtApp();\n    const writeFinalCookieValue = () => {\n      if (!isEqual(cookie.value, cookies[name])) {\n        writeServerCookie(useRequestEvent(nuxtApp), name, cookie.value, opts);\n      }\n    };\n    const unhook = nuxtApp.hooks.hookOnce(\"app:rendered\", writeFinalCookieValue);\n    nuxtApp.hooks.hookOnce(\"app:redirected\", () => {\n      unhook();\n      return writeFinalCookieValue();\n    });\n  }\n  return cookie;\n}\nfunction readRawCookies(opts = {}) {\n  if (process.server) {\n    return parse(useRequestEvent()?.req.headers.cookie || \"\", opts);\n  } else if (process.client) {\n    return parse(document.cookie, opts);\n  }\n}\nfunction serializeCookie(name, value, opts = {}) {\n  if (value === null || value === void 0) {\n    return serialize(name, value, { ...opts, maxAge: -1 });\n  }\n  return serialize(name, value, opts);\n}\nfunction writeClientCookie(name, value, opts = {}) {\n  if (process.client) {\n    document.cookie = serializeCookie(name, value, opts);\n  }\n}\nfunction writeServerCookie(event, name, value, opts = {}) {\n  if (event) {\n    appendHeader(event, \"Set-Cookie\", serializeCookie(name, value, opts));\n  }\n}\n", "export const requestIdleCallback = process.server ? void 0 : globalThis.requestIdleCallback || ((cb) => {\n  const start = Date.now();\n  const idleDeadline = {\n    didTimeout: false,\n    timeRemaining: () => Math.max(0, 50 - (Date.now() - start))\n  };\n  return setTimeout(() => {\n    cb(idleDeadline);\n  }, 1);\n});\nexport const cancelIdleCallback = process.server ? null : globalThis.cancelIdleCallback || ((id) => {\n  clearTimeout(id);\n});\n", "import { useNuxtApp } from \"../nuxt.mjs\";\nimport { requestIdleCallback } from \"../compat/idle-callback.mjs\";\nexport const onNuxtReady = (callback) => {\n  const nuxtApp = useNuxtApp();\n  if (nuxtApp.isHydrating) {\n    nuxtApp.hooks.hookOnce(\"app:suspense:resolve\", () => {\n      requestIdleCallback(callback);\n    });\n  } else {\n    requestIdleCallback(callback);\n  }\n};\n", "import { useNuxtApp } from \"../nuxt.mjs\";\nimport { useRouter } from \"./router.mjs\";\nexport const preloadComponents = async (components) => {\n  if (process.server) {\n    return;\n  }\n  const nuxtApp = useNuxtApp();\n  components = Array.isArray(components) ? components : [components];\n  await Promise.all(components.map((name) => _loadAsyncComponent(nuxtApp.vueApp._context.components[name])));\n};\nexport const prefetchComponents = (components) => {\n  return preloadComponents(components);\n};\nfunction _loadAsyncComponent(component) {\n  if (component?.__asyncLoader && !component.__asyncResolved) {\n    return component.__asyncLoader();\n  }\n}\nexport async function preloadRouteComponents(to, router = useRouter()) {\n  if (process.server) {\n    return;\n  }\n  if (!router._routePreloaded) {\n    router._routePreloaded = /* @__PURE__ */ new Set();\n  }\n  if (router._routePreloaded.has(to)) {\n    return;\n  }\n  router._routePreloaded.add(to);\n  const promises = router._preloadPromises = router._preloadPromises || [];\n  if (promises.length > 4) {\n    return Promise.all(promises).then(() => preloadRouteComponents(to, router));\n  }\n  const components = router.resolve(to).matched.map((component) => component.components?.default).filter((component) => typeof component === \"function\");\n  for (const component of components) {\n    const promise = Promise.resolve(component()).catch(() => {\n    }).finally(() => promises.splice(promises.indexOf(promise)));\n    promises.push(promise);\n  }\n  await Promise.all(promises);\n}\n", "import { joinURL } from \"ufo\";\nimport { useNuxtApp } from \"../nuxt.mjs\";\nimport { useHead, useRuntimeConfig } from \"../index.mjs\";\nexport function loadPayload(url, opts = {}) {\n  if (process.server) {\n    return null;\n  }\n  const payloadURL = _getPayloadURL(url, opts);\n  const nuxtApp = useNuxtApp();\n  const cache = nuxtApp._payloadCache = nuxtApp._payloadCache || {};\n  if (cache[url]) {\n    return cache[url];\n  }\n  cache[url] = _importPayload(payloadURL).then((payload) => {\n    if (!payload) {\n      delete cache[url];\n      return null;\n    }\n    return payload;\n  });\n  return cache[url];\n}\nexport function preloadPayload(url, opts = {}) {\n  const payloadURL = _getPayloadURL(url, opts);\n  useHead({\n    link: [\n      { rel: \"modulepreload\", href: payloadURL }\n    ]\n  });\n}\nfunction _getPayloadURL(url, opts = {}) {\n  const u = new URL(url, \"http://localhost\");\n  if (u.search) {\n    throw new Error(\"Payload URL cannot contain search params: \" + url);\n  }\n  if (u.host !== \"localhost\") {\n    throw new Error(\"Payload URL cannot contain host: \" + url);\n  }\n  const hash = opts.hash || (opts.fresh ? Date.now() : \"\");\n  return joinURL(useRuntimeConfig().app.baseURL, u.pathname, hash ? `_payload.${hash}.js` : \"_payload.js\");\n}\nasync function _importPayload(payloadURL) {\n  if (process.server) {\n    return null;\n  }\n  const res = await import(\n    /* webpackIgnore: true */\n    /* @vite-ignore */\n    payloadURL\n  ).catch((err) => {\n    console.warn(\"[nuxt] Cannot load payload \", payloadURL, err);\n  });\n  return res?.default || null;\n}\nexport function isPrerendered() {\n  const nuxtApp = useNuxtApp();\n  return !!nuxtApp.payload.prerenderedAt;\n}\n", "import { defineComponent, h, ref, resolveComponent, computed, onMounted, onBeforeUnmount } from \"vue\";\nimport { hasProtocol } from \"ufo\";\nimport { preloadRouteComponents } from \"../composables/preload.mjs\";\nimport { onNuxtReady } from \"../composables/ready.mjs\";\nimport { navigateTo, useRouter } from \"../composables/router.mjs\";\nimport { useNuxtApp } from \"../nuxt.mjs\";\nimport { cancelIdleCallback, requestIdleCallback } from \"../compat/idle-callback.mjs\";\nconst firstNonUndefined = (...args) => args.find((arg) => arg !== void 0);\nconst DEFAULT_EXTERNAL_REL_ATTRIBUTE = \"noopener noreferrer\";\nexport function defineNuxtLink(options) {\n  const componentName = options.componentName || \"NuxtLink\";\n  const checkPropConflicts = (props, main, sub) => {\n    if (process.dev && props[main] !== void 0 && props[sub] !== void 0) {\n      console.warn(`[${componentName}] \\`${main}\\` and \\`${sub}\\` cannot be used together. \\`${sub}\\` will be ignored.`);\n    }\n  };\n  return defineComponent({\n    name: componentName,\n    props: {\n      // Routing\n      to: {\n        type: [String, Object],\n        default: void 0,\n        required: false\n      },\n      href: {\n        type: [String, Object],\n        default: void 0,\n        required: false\n      },\n      // Attributes\n      target: {\n        type: String,\n        default: void 0,\n        required: false\n      },\n      rel: {\n        type: String,\n        default: void 0,\n        required: false\n      },\n      noRel: {\n        type: Boolean,\n        default: void 0,\n        required: false\n      },\n      // Prefetching\n      prefetch: {\n        type: Boolean,\n        default: void 0,\n        required: false\n      },\n      noPrefetch: {\n        type: Boolean,\n        default: void 0,\n        required: false\n      },\n      // Styling\n      activeClass: {\n        type: String,\n        default: void 0,\n        required: false\n      },\n      exactActiveClass: {\n        type: String,\n        default: void 0,\n        required: false\n      },\n      prefetchedClass: {\n        type: String,\n        default: void 0,\n        required: false\n      },\n      // Vue Router's `<RouterLink>` additional props\n      replace: {\n        type: Boolean,\n        default: void 0,\n        required: false\n      },\n      ariaCurrentValue: {\n        type: String,\n        default: void 0,\n        required: false\n      },\n      // Edge cases handling\n      external: {\n        type: Boolean,\n        default: void 0,\n        required: false\n      },\n      // Slot API\n      custom: {\n        type: Boolean,\n        default: void 0,\n        required: false\n      }\n    },\n    setup(props, { slots }) {\n      const router = useRouter();\n      const to = computed(() => {\n        checkPropConflicts(props, \"to\", \"href\");\n        return props.to || props.href || \"\";\n      });\n      const isExternal = computed(() => {\n        if (props.external) {\n          return true;\n        }\n        if (props.target && props.target !== \"_self\") {\n          return true;\n        }\n        if (typeof to.value === \"object\") {\n          return false;\n        }\n        return to.value === \"\" || hasProtocol(to.value, true);\n      });\n      const prefetched = ref(false);\n      const el = process.server ? void 0 : ref(null);\n      if (process.client) {\n        checkPropConflicts(props, \"prefetch\", \"noPrefetch\");\n        const shouldPrefetch = props.prefetch !== false && props.noPrefetch !== true && typeof to.value === \"string\" && props.target !== \"_blank\" && !isSlowConnection();\n        if (shouldPrefetch) {\n          const nuxtApp = useNuxtApp();\n          let idleId;\n          let unobserve = null;\n          onMounted(() => {\n            const observer = useObserver();\n            onNuxtReady(() => {\n              idleId = requestIdleCallback(() => {\n                if (el?.value?.tagName) {\n                  unobserve = observer.observe(el.value, async () => {\n                    unobserve?.();\n                    unobserve = null;\n                    await Promise.all([\n                      nuxtApp.hooks.callHook(\"link:prefetch\", to.value).catch(() => {\n                      }),\n                      !isExternal.value && preloadRouteComponents(to.value, router).catch(() => {\n                      })\n                    ]);\n                    prefetched.value = true;\n                  });\n                }\n              });\n            });\n          });\n          onBeforeUnmount(() => {\n            if (idleId) {\n              cancelIdleCallback(idleId);\n            }\n            unobserve?.();\n            unobserve = null;\n          });\n        }\n      }\n      return () => {\n        if (!isExternal.value) {\n          return h(\n            resolveComponent(\"RouterLink\"),\n            {\n              ref: process.server ? void 0 : (ref2) => {\n                el.value = ref2?.$el;\n              },\n              to: to.value,\n              ...prefetched.value && !props.custom ? { class: props.prefetchedClass || options.prefetchedClass } : {},\n              activeClass: props.activeClass || options.activeClass,\n              exactActiveClass: props.exactActiveClass || options.exactActiveClass,\n              replace: props.replace,\n              ariaCurrentValue: props.ariaCurrentValue,\n              custom: props.custom\n            },\n            slots.default\n          );\n        }\n        const href = typeof to.value === \"object\" ? router.resolve(to.value)?.href ?? null : to.value || null;\n        const target = props.target || null;\n        checkPropConflicts(props, \"noRel\", \"rel\");\n        const rel = props.noRel ? null : firstNonUndefined(props.rel, options.externalRelAttribute, href ? DEFAULT_EXTERNAL_REL_ATTRIBUTE : \"\") || null;\n        const navigate = () => navigateTo(href, { replace: props.replace });\n        if (props.custom) {\n          if (!slots.default) {\n            return null;\n          }\n          return slots.default({\n            href,\n            navigate,\n            route: router.resolve(href),\n            rel,\n            target,\n            isExternal: isExternal.value,\n            isActive: false,\n            isExactActive: false\n          });\n        }\n        return h(\"a\", { ref: el, href, rel, target }, slots.default?.());\n      };\n    }\n  });\n}\nexport default defineNuxtLink({ componentName: \"NuxtLink\" });\nfunction useObserver() {\n  if (process.server) {\n    return;\n  }\n  const nuxtApp = useNuxtApp();\n  if (nuxtApp._observer) {\n    return nuxtApp._observer;\n  }\n  let observer = null;\n  const callbacks = /* @__PURE__ */ new Map();\n  const observe = (element, callback) => {\n    if (!observer) {\n      observer = new IntersectionObserver((entries) => {\n        for (const entry of entries) {\n          const callback2 = callbacks.get(entry.target);\n          const isVisible = entry.isIntersecting || entry.intersectionRatio > 0;\n          if (isVisible && callback2) {\n            callback2();\n          }\n        }\n      });\n    }\n    callbacks.set(element, callback);\n    observer.observe(element);\n    return () => {\n      callbacks.delete(element);\n      observer.unobserve(element);\n      if (callbacks.size === 0) {\n        observer.disconnect();\n        observer = null;\n      }\n    };\n  };\n  const _observer = nuxtApp._observer = {\n    observe\n  };\n  return _observer;\n}\nfunction isSlowConnection() {\n  if (process.server) {\n    return;\n  }\n  const cn = navigator.connection;\n  if (cn && (cn.saveData || /2g/.test(cn.effectiveType))) {\n    return true;\n  }\n  return false;\n}\n", "function isObject(value) {\n  return value !== null && typeof value === \"object\";\n}\nfunction _defu(baseObject, defaults, namespace = \".\", merger) {\n  if (!isObject(defaults)) {\n    return _defu(baseObject, {}, namespace, merger);\n  }\n  const object = Object.assign({}, defaults);\n  for (const key in baseObject) {\n    if (key === \"__proto__\" || key === \"constructor\") {\n      continue;\n    }\n    const value = baseObject[key];\n    if (value === null || value === void 0) {\n      continue;\n    }\n    if (merger && merger(object, key, value, namespace)) {\n      continue;\n    }\n    if (Array.isArray(value) && Array.isArray(object[key])) {\n      object[key] = [...value, ...object[key]];\n    } else if (isObject(value) && isObject(object[key])) {\n      object[key] = _defu(\n        value,\n        object[key],\n        (namespace ? `${namespace}.` : \"\") + key.toString(),\n        merger\n      );\n    } else {\n      object[key] = value;\n    }\n  }\n  return object;\n}\nfunction createDefu(merger) {\n  return (...arguments_) => (\n    // eslint-disable-next-line unicorn/no-array-reduce\n    arguments_.reduce((p, c) => _defu(p, c, \"\", merger), {})\n  );\n}\nconst defu = createDefu();\nconst defuFn = createDefu((object, key, currentValue) => {\n  if (typeof object[key] !== \"undefined\" && typeof currentValue === \"function\") {\n    object[key] = currentValue(object[key]);\n    return true;\n  }\n});\nconst defuArrayFn = createDefu((object, key, currentValue) => {\n  if (Array.isArray(object[key]) && typeof currentValue === \"function\") {\n    object[key] = currentValue(object[key]);\n    return true;\n  }\n});\n\nexport { createDefu, defu as default, defu, defuArrayFn, defuFn };\n", "\nimport { defuFn } from 'F:/PROJECTS/2023/highjob/node_modules/defu/dist/defu.mjs'\n\nconst inlineConfig = {}\n\n\n\nexport default defuFn(inlineConfig)\n", "import { reactive } from \"vue\";\nimport { useNuxtApp } from \"./nuxt.mjs\";\nimport __appConfig from \"#build/app.config.mjs\";\nexport const _getAppConfig = () => __appConfig;\nfunction deepDelete(obj, newObj) {\n  for (const key in obj) {\n    const val = newObj[key];\n    if (!(key in newObj)) {\n      delete obj[key];\n    }\n    if (val !== null && typeof val === \"object\") {\n      deepDelete(obj[key], newObj[key]);\n    }\n  }\n}\nfunction deepAssign(obj, newObj) {\n  for (const key in newObj) {\n    const val = newObj[key];\n    if (val !== null && typeof val === \"object\") {\n      obj[key] = obj[key] || {};\n      deepAssign(obj[key], val);\n    } else {\n      obj[key] = val;\n    }\n  }\n}\nexport function useAppConfig() {\n  const nuxtApp = useNuxtApp();\n  if (!nuxtApp._appConfig) {\n    nuxtApp._appConfig = reactive(__appConfig);\n  }\n  return nuxtApp._appConfig;\n}\nexport function updateAppConfig(appConfig) {\n  const _appConfig = useAppConfig();\n  deepAssign(_appConfig, appConfig);\n}\nif (process.dev) {\n  let applyHMR = function(newConfig) {\n    const appConfig = useAppConfig();\n    if (newConfig && appConfig) {\n      deepAssign(appConfig, newConfig);\n      deepDelete(appConfig, newConfig);\n    }\n  };\n  if (import.meta.hot) {\n    import.meta.hot.accept((newModule) => {\n      const newConfig = newModule._getAppConfig();\n      applyHMR(newConfig);\n    });\n  }\n  if (import.meta.webpackHot) {\n    import.meta.webpackHot.accept(\"#build/app.config.mjs\", () => {\n      applyHMR(__appConfig);\n    });\n  }\n}\n", "export * from \"./nuxt.mjs\";\nexport * from \"./composables/index.mjs\";\nexport * from \"./components/index.mjs\";\nexport * from \"./config.mjs\";\nexport { useHead } from \"#head\";\nexport const isVue2 = false;\nexport const isVue3 = true;\n"],
  "mappings": "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",
  "names": ["r", "hash", "location", "createError", "createError", "_a", "createError", "useHead", "useHead", "h", "r", "pick", "watch", "useHead", "hash", "defaults"]
}
